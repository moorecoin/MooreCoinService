/*
 * copyright 2011 martin gieseking <martin.gieseking@uos.de>.
 *
 * redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * neither the name of google inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * this software is provided by the copyright holders and contributors
 * "as is" and any express or implied warranties, including, but not
 * limited to, the implied warranties of merchantability and fitness for
 * a particular purpose are disclaimed. in no event shall the copyright
 * owner or contributors be liable for any direct, indirect, incidental,
 * special, exemplary, or consequential damages (including, but not
 * limited to, procurement of substitute goods or services; loss of use,
 * data, or profits; or business interruption) however caused and on any
 * theory of liability, whether in contract, strict liability, or tort
 * (including negligence or otherwise) arising in any way out of the use
 * of this software, even if advised of the possibility of such damage.
 *
 * plain c interface (a wrapper around the c++ implementation).
 */

#ifndef util_snappy_opensource_snappy_c_h_
#define util_snappy_opensource_snappy_c_h_

#ifdef __cplusplus
extern "c" {
#endif

#include <stddef.h>

/*
 * return values; see the documentation for each function to know
 * what each can return.
 */
typedef enum {
  snappy_ok = 0,
  snappy_invalid_input = 1,
  snappy_buffer_too_small = 2
} snappy_status;

/*
 * takes the data stored in "input[0..input_length-1]" and stores
 * it in the array pointed to by "compressed".
 *
 * <compressed_length> signals the space available in "compressed".
 * if it is not at least equal to "snappy_max_compressed_length(input_length)",
 * snappy_buffer_too_small is returned. after successful compression,
 * <compressed_length> contains the true length of the compressed output,
 * and snappy_ok is returned.
 *
 * example:
 *   size_t output_length = snappy_max_compressed_length(input_length);
 *   char* output = (char*)malloc(output_length);
 *   if (snappy_compress(input, input_length, output, &output_length)
 *       == snappy_ok) {
 *     ... process(output, output_length) ...
 *   }
 *   free(output);
 */
snappy_status snappy_compress(const char* input,
                              size_t input_length,
                              char* compressed,
                              size_t* compressed_length);

/*
 * given data in "compressed[0..compressed_length-1]" generated by
 * calling the snappy_compress routine, this routine stores
 * the uncompressed data to
 *   uncompressed[0..uncompressed_length-1].
 * returns failure (a value not equal to snappy_ok) if the message
 * is corrupted and could not be decrypted.
 *
 * <uncompressed_length> signals the space available in "uncompressed".
 * if it is not at least equal to the value returned by
 * snappy_uncompressed_length for this stream, snappy_buffer_too_small
 * is returned. after successful decompression, <uncompressed_length>
 * contains the true length of the decompressed output.
 *
 * example:
 *   size_t output_length;
 *   if (snappy_uncompressed_length(input, input_length, &output_length)
 *       != snappy_ok) {
 *     ... fail ...
 *   }
 *   char* output = (char*)malloc(output_length);
 *   if (snappy_uncompress(input, input_length, output, &output_length)
 *       == snappy_ok) {
 *     ... process(output, output_length) ...
 *   }
 *   free(output);
 */
snappy_status snappy_uncompress(const char* compressed,
                                size_t compressed_length,
                                char* uncompressed,
                                size_t* uncompressed_length);

/*
 * returns the maximal size of the compressed representation of
 * input data that is "source_length" bytes in length.
 */
size_t snappy_max_compressed_length(size_t source_length);

/*
 * requires: "compressed[]" was produced by snappy_compress()
 * returns snappy_ok and stores the length of the uncompressed data in
 * *result normally. returns snappy_invalid_input on parsing error.
 * this operation takes o(1) time.
 */
snappy_status snappy_uncompressed_length(const char* compressed,
                                         size_t compressed_length,
                                         size_t* result);

/*
 * check if the contents of "compressed[]" can be uncompressed successfully.
 * does not return the uncompressed data; if so, returns snappy_ok,
 * or if not, returns snappy_invalid_input.
 * takes time proportional to compressed_length, but is usually at least a
 * factor of four faster than actual decompression.
 */
snappy_status snappy_validate_compressed_buffer(const char* compressed,
                                                size_t compressed_length);

#ifdef __cplusplus
}  // extern "c"
#endif

#endif  /* util_snappy_opensource_snappy_c_h_ */
