# protocol buffers - google's data interchange format
# copyright 2008 google inc.  all rights reserved.
# http://code.google.com/p/protobuf/
#
# redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * neither the name of google inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# this software is provided by the copyright holders and contributors
# "as is" and any express or implied warranties, including, but not
# limited to, the implied warranties of merchantability and fitness for
# a particular purpose are disclaimed. in no event shall the copyright
# owner or contributors be liable for any direct, indirect, incidental,
# special, exemplary, or consequential damages (including, but not
# limited to, procurement of substitute goods or services; loss of use,
# data, or profits; or business interruption) however caused and on any
# theory of liability, whether in contract, strict liability, or tort
# (including negligence or otherwise) arising in any way out of the use
# of this software, even if advised of the possibility of such damage.

"""provides descriptorpool to use as a container for proto2 descriptors.

the descriptorpool is used in conjection with a descriptordatabase to maintain
a collection of protocol buffer descriptors for use when dynamically creating
message types at runtime.

for most applications protocol buffers should be used via modules generated by
the protocol buffer compiler tool. this should only be used when the type of
protocol buffers used in an application or library cannot be predetermined.

below is a straightforward example on how to use this class:

  pool = descriptorpool()
  file_descriptor_protos = [ ... ]
  for file_descriptor_proto in file_descriptor_protos:
    pool.add(file_descriptor_proto)
  my_message_descriptor = pool.findmessagetypebyname('some.package.messagetype')

the message descriptor can be used in conjunction with the message_factory
module in order to create a protocol buffer class that can be encoded and
decoded.
"""

__author__ = 'matthewtoia@google.com (matt toia)'

from google.protobuf import descriptor_pb2
from google.protobuf import descriptor
from google.protobuf import descriptor_database


class descriptorpool(object):
  """a collection of protobufs dynamically constructed by descriptor protos."""

  def __init__(self, descriptor_db=none):
    """initializes a pool of proto buffs.

    the descriptor_db argument to the constructor is provided to allow
    specialized file descriptor proto lookup code to be triggered on demand. an
    example would be an implementation which will read and compile a file
    specified in a call to findfilebyname() and not require the call to add()
    at all. results from this database will be cached internally here as well.

    args:
      descriptor_db: a secondary source of file descriptors.
    """

    self._internal_db = descriptor_database.descriptordatabase()
    self._descriptor_db = descriptor_db
    self._descriptors = {}
    self._enum_descriptors = {}
    self._file_descriptors = {}

  def add(self, file_desc_proto):
    """adds the filedescriptorproto and its types to this pool.

    args:
      file_desc_proto: the filedescriptorproto to add.
    """

    self._internal_db.add(file_desc_proto)

  def findfilebyname(self, file_name):
    """gets a filedescriptor by file name.

    args:
      file_name: the path to the file to get a descriptor for.

    returns:
      a filedescriptor for the named file.

    raises:
      keyerror: if the file can not be found in the pool.
    """

    try:
      file_proto = self._internal_db.findfilebyname(file_name)
    except keyerror as error:
      if self._descriptor_db:
        file_proto = self._descriptor_db.findfilebyname(file_name)
      else:
        raise error
    if not file_proto:
      raise keyerror('cannot find a file named %s' % file_name)
    return self._convertfileprototofiledescriptor(file_proto)

  def findfilecontainingsymbol(self, symbol):
    """gets the filedescriptor for the file containing the specified symbol.

    args:
      symbol: the name of the symbol to search for.

    returns:
      a filedescriptor that contains the specified symbol.

    raises:
      keyerror: if the file can not be found in the pool.
    """

    try:
      file_proto = self._internal_db.findfilecontainingsymbol(symbol)
    except keyerror as error:
      if self._descriptor_db:
        file_proto = self._descriptor_db.findfilecontainingsymbol(symbol)
      else:
        raise error
    if not file_proto:
      raise keyerror('cannot find a file containing %s' % symbol)
    return self._convertfileprototofiledescriptor(file_proto)

  def findmessagetypebyname(self, full_name):
    """loads the named descriptor from the pool.

    args:
      full_name: the full name of the descriptor to load.

    returns:
      the descriptor for the named type.
    """

    full_name = full_name.lstrip('.')  # fix inconsistent qualified name formats
    if full_name not in self._descriptors:
      self.findfilecontainingsymbol(full_name)
    return self._descriptors[full_name]

  def findenumtypebyname(self, full_name):
    """loads the named enum descriptor from the pool.

    args:
      full_name: the full name of the enum descriptor to load.

    returns:
      the enum descriptor for the named type.
    """

    full_name = full_name.lstrip('.')  # fix inconsistent qualified name formats
    if full_name not in self._enum_descriptors:
      self.findfilecontainingsymbol(full_name)
    return self._enum_descriptors[full_name]

  def _convertfileprototofiledescriptor(self, file_proto):
    """creates a filedescriptor from a proto or returns a cached copy.

    this method also has the side effect of loading all the symbols found in
    the file into the appropriate dictionaries in the pool.

    args:
      file_proto: the proto to convert.

    returns:
      a filedescriptor matching the passed in proto.
    """

    if file_proto.name not in self._file_descriptors:
      file_descriptor = descriptor.filedescriptor(
          name=file_proto.name,
          package=file_proto.package,
          options=file_proto.options,
          serialized_pb=file_proto.serializetostring())
      scope = {}
      dependencies = list(self._getdeps(file_proto))

      for dependency in dependencies:
        dep_desc = self.findfilebyname(dependency.name)
        dep_proto = descriptor_pb2.filedescriptorproto.fromstring(
            dep_desc.serialized_pb)
        package = '.' + dep_proto.package
        package_prefix = package + '.'

        def _strip_package(symbol):
          if symbol.startswith(package_prefix):
            return symbol[len(package_prefix):]
          return symbol

        symbols = list(self._extractsymbols(dep_proto.message_type, package))
        scope.update(symbols)
        scope.update((_strip_package(k), v) for k, v in symbols)

        symbols = list(self._extractenums(dep_proto.enum_type, package))
        scope.update(symbols)
        scope.update((_strip_package(k), v) for k, v in symbols)

      for message_type in file_proto.message_type:
        message_desc = self._convertmessagedescriptor(
            message_type, file_proto.package, file_descriptor, scope)
        file_descriptor.message_types_by_name[message_desc.name] = message_desc
      for enum_type in file_proto.enum_type:
        self._convertenumdescriptor(enum_type, file_proto.package,
                                    file_descriptor, none, scope)
      for desc_proto in self._extractmessages(file_proto.message_type):
        self._setfieldtypes(desc_proto, scope)

      for desc_proto in file_proto.message_type:
        desc = scope[desc_proto.name]
        file_descriptor.message_types_by_name[desc_proto.name] = desc
      self.add(file_proto)
      self._file_descriptors[file_proto.name] = file_descriptor

    return self._file_descriptors[file_proto.name]

  def _convertmessagedescriptor(self, desc_proto, package=none, file_desc=none,
                                scope=none):
    """adds the proto to the pool in the specified package.

    args:
      desc_proto: the descriptor_pb2.descriptorproto protobuf message.
      package: the package the proto should be located in.
      file_desc: the file containing this message.
      scope: dict mapping short and full symbols to message and enum types.

    returns:
      the added descriptor.
    """

    if package:
      desc_name = '.'.join((package, desc_proto.name))
    else:
      desc_name = desc_proto.name

    if file_desc is none:
      file_name = none
    else:
      file_name = file_desc.name

    if scope is none:
      scope = {}

    nested = [
        self._convertmessagedescriptor(nested, desc_name, file_desc, scope)
        for nested in desc_proto.nested_type]
    enums = [
        self._convertenumdescriptor(enum, desc_name, file_desc, none, scope)
        for enum in desc_proto.enum_type]
    fields = [self._makefielddescriptor(field, desc_name, index)
              for index, field in enumerate(desc_proto.field)]
    extensions = [self._makefielddescriptor(extension, desc_name, true)
                  for index, extension in enumerate(desc_proto.extension)]
    extension_ranges = [(r.start, r.end) for r in desc_proto.extension_range]
    if extension_ranges:
      is_extendable = true
    else:
      is_extendable = false
    desc = descriptor.descriptor(
        name=desc_proto.name,
        full_name=desc_name,
        filename=file_name,
        containing_type=none,
        fields=fields,
        nested_types=nested,
        enum_types=enums,
        extensions=extensions,
        options=desc_proto.options,
        is_extendable=is_extendable,
        extension_ranges=extension_ranges,
        file=file_desc,
        serialized_start=none,
        serialized_end=none)
    for nested in desc.nested_types:
      nested.containing_type = desc
    for enum in desc.enum_types:
      enum.containing_type = desc
    scope[desc_proto.name] = desc
    scope['.' + desc_name] = desc
    self._descriptors[desc_name] = desc
    return desc

  def _convertenumdescriptor(self, enum_proto, package=none, file_desc=none,
                             containing_type=none, scope=none):
    """make a protobuf enumdescriptor given an enumdescriptorproto protobuf.

    args:
      enum_proto: the descriptor_pb2.enumdescriptorproto protobuf message.
      package: optional package name for the new message enumdescriptor.
      file_desc: the file containing the enum descriptor.
      containing_type: the type containing this enum.
      scope: scope containing available types.

    returns:
      the added descriptor
    """

    if package:
      enum_name = '.'.join((package, enum_proto.name))
    else:
      enum_name = enum_proto.name

    if file_desc is none:
      file_name = none
    else:
      file_name = file_desc.name

    values = [self._makeenumvaluedescriptor(value, index)
              for index, value in enumerate(enum_proto.value)]
    desc = descriptor.enumdescriptor(name=enum_proto.name,
                                     full_name=enum_name,
                                     filename=file_name,
                                     file=file_desc,
                                     values=values,
                                     containing_type=containing_type,
                                     options=enum_proto.options)
    scope[enum_proto.name] = desc
    scope['.%s' % enum_name] = desc
    self._enum_descriptors[enum_name] = desc
    return desc

  def _makefielddescriptor(self, field_proto, message_name, index,
                           is_extension=false):
    """creates a field descriptor from a fielddescriptorproto.

    for message and enum type fields, this method will do a look up
    in the pool for the appropriate descriptor for that type. if it
    is unavailable, it will fall back to the _source function to
    create it. if this type is still unavailable, construction will
    fail.

    args:
      field_proto: the proto describing the field.
      message_name: the name of the containing message.
      index: index of the field
      is_extension: indication that this field is for an extension.

    returns:
      an initialized fielddescriptor object
    """

    if message_name:
      full_name = '.'.join((message_name, field_proto.name))
    else:
      full_name = field_proto.name

    return descriptor.fielddescriptor(
        name=field_proto.name,
        full_name=full_name,
        index=index,
        number=field_proto.number,
        type=field_proto.type,
        cpp_type=none,
        message_type=none,
        enum_type=none,
        containing_type=none,
        label=field_proto.label,
        has_default_value=false,
        default_value=none,
        is_extension=is_extension,
        extension_scope=none,
        options=field_proto.options)

  def _setfieldtypes(self, desc_proto, scope):
    """sets the field's type, cpp_type, message_type and enum_type.

    args:
      desc_proto: the message descriptor to update.
      scope: enclosing scope of available types.
    """

    desc = scope[desc_proto.name]
    for field_proto, field_desc in zip(desc_proto.field, desc.fields):
      if field_proto.type_name:
        type_name = field_proto.type_name
        if type_name not in scope:
          type_name = '.' + type_name
        desc = scope[type_name]
      else:
        desc = none

      if not field_proto.hasfield('type'):
        if isinstance(desc, descriptor.descriptor):
          field_proto.type = descriptor.fielddescriptor.type_message
        else:
          field_proto.type = descriptor.fielddescriptor.type_enum

      field_desc.cpp_type = descriptor.fielddescriptor.prototypetocppprototype(
          field_proto.type)

      if (field_proto.type == descriptor.fielddescriptor.type_message
          or field_proto.type == descriptor.fielddescriptor.type_group):
        field_desc.message_type = desc

      if field_proto.type == descriptor.fielddescriptor.type_enum:
        field_desc.enum_type = desc

      if field_proto.label == descriptor.fielddescriptor.label_repeated:
        field_desc.has_default = false
        field_desc.default_value = []
      elif field_proto.hasfield('default_value'):
        field_desc.has_default = true
        if (field_proto.type == descriptor.fielddescriptor.type_double or
            field_proto.type == descriptor.fielddescriptor.type_float):
          field_desc.default_value = float(field_proto.default_value)
        elif field_proto.type == descriptor.fielddescriptor.type_string:
          field_desc.default_value = field_proto.default_value
        elif field_proto.type == descriptor.fielddescriptor.type_bool:
          field_desc.default_value = field_proto.default_value.lower() == 'true'
        elif field_proto.type == descriptor.fielddescriptor.type_enum:
          field_desc.default_value = field_desc.enum_type.values_by_name[
              field_proto.default_value].index
        else:
          field_desc.default_value = int(field_proto.default_value)
      else:
        field_desc.has_default = false
        field_desc.default_value = none

      field_desc.type = field_proto.type

    for nested_type in desc_proto.nested_type:
      self._setfieldtypes(nested_type, scope)

  def _makeenumvaluedescriptor(self, value_proto, index):
    """creates a enum value descriptor object from a enum value proto.

    args:
      value_proto: the proto describing the enum value.
      index: the index of the enum value.

    returns:
      an initialized enumvaluedescriptor object.
    """

    return descriptor.enumvaluedescriptor(
        name=value_proto.name,
        index=index,
        number=value_proto.number,
        options=value_proto.options,
        type=none)

  def _extractsymbols(self, desc_protos, package):
    """pulls out all the symbols from descriptor protos.

    args:
      desc_protos: the protos to extract symbols from.
      package: the package containing the descriptor type.
    yields:
      a two element tuple of the type name and descriptor object.
    """

    for desc_proto in desc_protos:
      if package:
        message_name = '.'.join((package, desc_proto.name))
      else:
        message_name = desc_proto.name
      message_desc = self.findmessagetypebyname(message_name)
      yield (message_name, message_desc)
      for symbol in self._extractsymbols(desc_proto.nested_type, message_name):
        yield symbol
      for symbol in self._extractenums(desc_proto.enum_type, message_name):
        yield symbol

  def _extractenums(self, enum_protos, package):
    """pulls out all the symbols from enum protos.

    args:
      enum_protos: the protos to extract symbols from.
      package: the package containing the enum type.

    yields:
      a two element tuple of the type name and enum descriptor object.
    """

    for enum_proto in enum_protos:
      if package:
        enum_name = '.'.join((package, enum_proto.name))
      else:
        enum_name = enum_proto.name
      enum_desc = self.findenumtypebyname(enum_name)
      yield (enum_name, enum_desc)

  def _extractmessages(self, desc_protos):
    """pulls out all the message protos from descriptos.

    args:
      desc_protos: the protos to extract symbols from.

    yields:
      descriptor protos.
    """

    for desc_proto in desc_protos:
      yield desc_proto
      for message in self._extractmessages(desc_proto.nested_type):
        yield message

  def _getdeps(self, file_proto):
    """recursively finds dependencies for file protos.

    args:
      file_proto: the proto to get dependencies from.

    yields:
      each direct and indirect dependency.
    """

    for dependency in file_proto.dependency:
      dep_desc = self.findfilebyname(dependency)
      dep_proto = descriptor_pb2.filedescriptorproto.fromstring(
          dep_desc.serialized_pb)
      yield dep_proto
      for parent_dep in self._getdeps(dep_proto):
        yield parent_dep
