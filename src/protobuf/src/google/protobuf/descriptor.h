// protocol buffers - google's data interchange format
// copyright 2008 google inc.  all rights reserved.
// http://code.google.com/p/protobuf/
//
// redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * neither the name of google inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// this software is provided by the copyright holders and contributors
// "as is" and any express or implied warranties, including, but not
// limited to, the implied warranties of merchantability and fitness for
// a particular purpose are disclaimed. in no event shall the copyright
// owner or contributors be liable for any direct, indirect, incidental,
// special, exemplary, or consequential damages (including, but not
// limited to, procurement of substitute goods or services; loss of use,
// data, or profits; or business interruption) however caused and on any
// theory of liability, whether in contract, strict liability, or tort
// (including negligence or otherwise) arising in any way out of the use
// of this software, even if advised of the possibility of such damage.

// author: kenton@google.com (kenton varda)
//  based on original protocol buffers design by
//  sanjay ghemawat, jeff dean, and others.
//
// this file contains classes which describe a type of protocol message.
// you can use a message's descriptor to learn at runtime what fields
// it contains and what the types of those fields are.  the message
// interface also allows you to dynamically access and modify individual
// fields by passing the fielddescriptor of the field you are interested
// in.
//
// most users will not care about descriptors, because they will write
// code specific to certain protocol types and will simply use the classes
// generated by the protocol compiler directly.  advanced users who want
// to operate on arbitrary types (not known at compile time) may want to
// read descriptors in order to learn about the contents of a message.
// a very small number of users will want to construct their own
// descriptors, either because they are implementing message manually or
// because they are writing something like the protocol compiler.
//
// for an example of how you might use descriptors, see the code example
// at the top of message.h.

#ifndef google_protobuf_descriptor_h__
#define google_protobuf_descriptor_h__

#include <string>
#include <vector>
#include <google/protobuf/stubs/common.h>

// type_bool is defined in the macos's conditionalmacros.h.
#ifdef type_bool
#undef type_bool
#endif  // type_bool

namespace google {
namespace protobuf {

// defined in this file.
class descriptor;
class fielddescriptor;
class enumdescriptor;
class enumvaluedescriptor;
class servicedescriptor;
class methoddescriptor;
class filedescriptor;
class descriptordatabase;
class descriptorpool;

// defined in descriptor.proto
class descriptorproto;
class fielddescriptorproto;
class enumdescriptorproto;
class enumvaluedescriptorproto;
class servicedescriptorproto;
class methoddescriptorproto;
class filedescriptorproto;
class messageoptions;
class fieldoptions;
class enumoptions;
class enumvalueoptions;
class serviceoptions;
class methodoptions;
class fileoptions;
class uninterpretedoption;
class sourcecodeinfo;

// defined in message.h
class message;

// defined in descriptor.cc
class descriptorbuilder;
class filedescriptortables;

// defined in unknown_field_set.h.
class unknownfield;

// nb, all indices are zero-based.
struct sourcelocation {
  int start_line;
  int end_line;
  int start_column;
  int end_column;

  // doc comments found at the source location.
  // todo(kenton):  maybe this struct should have been named sourceinfo or
  //   something instead.  oh well.
  string leading_comments;
  string trailing_comments;
};

// describes a type of protocol message, or a particular group within a
// message.  to obtain the descriptor for a given message object, call
// message::getdescriptor().  generated message classes also have a
// static method called descriptor() which returns the type's descriptor.
// use descriptorpool to construct your own descriptors.
class libprotobuf_export descriptor {
 public:
  // the name of the message type, not including its scope.
  const string& name() const;

  // the fully-qualified name of the message type, scope delimited by
  // periods.  for example, message type "foo" which is declared in package
  // "bar" has full name "bar.foo".  if a type "baz" is nested within
  // foo, baz's full_name is "bar.foo.baz".  to get only the part that
  // comes after the last '.', use name().
  const string& full_name() const;

  // index of this descriptor within the file or containing type's message
  // type array.
  int index() const;

  // the .proto file in which this message type was defined.  never null.
  const filedescriptor* file() const;

  // if this descriptor describes a nested type, this returns the type
  // in which it is nested.  otherwise, returns null.
  const descriptor* containing_type() const;

  // get options for this message type.  these are specified in the .proto file
  // by placing lines like "option foo = 1234;" in the message definition.
  // allowed options are defined by messageoptions in
  // google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const messageoptions& options() const;

  // write the contents of this descriptor into the given descriptorproto.
  // the target descriptorproto must be clear before calling this; if it
  // isn't, the result may be garbage.
  void copyto(descriptorproto* proto) const;

  // write the contents of this decriptor in a human-readable form. output
  // will be suitable for re-parsing.
  string debugstring() const;

  // field stuff -----------------------------------------------------

  // the number of fields in this message type.
  int field_count() const;
  // gets a field by index, where 0 <= index < field_count().
  // these are returned in the order they were defined in the .proto file.
  const fielddescriptor* field(int index) const;

  // looks up a field by declared tag number.  returns null if no such field
  // exists.
  const fielddescriptor* findfieldbynumber(int number) const;
  // looks up a field by name.  returns null if no such field exists.
  const fielddescriptor* findfieldbyname(const string& name) const;

  // looks up a field by lowercased name (as returned by lowercase_name()).
  // this lookup may be ambiguous if multiple field names differ only by case,
  // in which case the field returned is chosen arbitrarily from the matches.
  const fielddescriptor* findfieldbylowercasename(
      const string& lowercase_name) const;

  // looks up a field by camel-case name (as returned by camelcase_name()).
  // this lookup may be ambiguous if multiple field names differ in a way that
  // leads them to have identical camel-case names, in which case the field
  // returned is chosen arbitrarily from the matches.
  const fielddescriptor* findfieldbycamelcasename(
      const string& camelcase_name) const;

  // nested type stuff -----------------------------------------------

  // the number of nested types in this message type.
  int nested_type_count() const;
  // gets a nested type by index, where 0 <= index < nested_type_count().
  // these are returned in the order they were defined in the .proto file.
  const descriptor* nested_type(int index) const;

  // looks up a nested type by name.  returns null if no such nested type
  // exists.
  const descriptor* findnestedtypebyname(const string& name) const;

  // enum stuff ------------------------------------------------------

  // the number of enum types in this message type.
  int enum_type_count() const;
  // gets an enum type by index, where 0 <= index < enum_type_count().
  // these are returned in the order they were defined in the .proto file.
  const enumdescriptor* enum_type(int index) const;

  // looks up an enum type by name.  returns null if no such enum type exists.
  const enumdescriptor* findenumtypebyname(const string& name) const;

  // looks up an enum value by name, among all enum types in this message.
  // returns null if no such value exists.
  const enumvaluedescriptor* findenumvaluebyname(const string& name) const;

  // extensions ------------------------------------------------------

  // a range of field numbers which are designated for third-party
  // extensions.
  struct extensionrange {
    int start;  // inclusive
    int end;    // exclusive
  };

  // the number of extension ranges in this message type.
  int extension_range_count() const;
  // gets an extension range by index, where 0 <= index <
  // extension_range_count(). these are returned in the order they were defined
  // in the .proto file.
  const extensionrange* extension_range(int index) const;

  // returns true if the number is in one of the extension ranges.
  bool isextensionnumber(int number) const;

  // the number of extensions -- extending *other* messages -- that were
  // defined nested within this message type's scope.
  int extension_count() const;
  // get an extension by index, where 0 <= index < extension_count().
  // these are returned in the order they were defined in the .proto file.
  const fielddescriptor* extension(int index) const;

  // looks up a named extension (which extends some *other* message type)
  // defined within this message type's scope.
  const fielddescriptor* findextensionbyname(const string& name) const;

  // similar to findfieldbylowercasename(), but finds extensions defined within
  // this message type's scope.
  const fielddescriptor* findextensionbylowercasename(const string& name) const;

  // similar to findfieldbycamelcasename(), but finds extensions defined within
  // this message type's scope.
  const fielddescriptor* findextensionbycamelcasename(const string& name) const;

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this message declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef messageoptions optionstype;

  // internal version of debugstring; controls the level of indenting for
  // correct depth
  void debugstring(int depth, string *contents) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  const filedescriptor* file_;
  const descriptor* containing_type_;
  const messageoptions* options_;

  // true if this is a placeholder for an unknown type.
  bool is_placeholder_;
  // true if this is a placeholder and the type name wasn't fully-qualified.
  bool is_unqualified_placeholder_;

  int field_count_;
  fielddescriptor* fields_;
  int nested_type_count_;
  descriptor* nested_types_;
  int enum_type_count_;
  enumdescriptor* enum_types_;
  int extension_range_count_;
  extensionrange* extension_ranges_;
  int extension_count_;
  fielddescriptor* extensions_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<descriptor>() and allocatearray<descriptor>() in descriptor.cc
  // and update them to initialize the field.

  // must be constructed using descriptorpool.
  descriptor() {}
  friend class descriptorbuilder;
  friend class enumdescriptor;
  friend class fielddescriptor;
  friend class methoddescriptor;
  friend class filedescriptor;
  google_disallow_evil_constructors(descriptor);
};

// describes a single field of a message.  to get the descriptor for a given
// field, first get the descriptor for the message in which it is defined,
// then call descriptor::findfieldbyname().  to get a fielddescriptor for
// an extension, do one of the following:
// - get the descriptor or filedescriptor for its containing scope, then
//   call descriptor::findextensionbyname() or
//   filedescriptor::findextensionbyname().
// - given a descriptorpool, call descriptorpool::findextensionbynumber().
// - given a reflection for a message object, call
//   reflection::findknownextensionbyname() or
//   reflection::findknownextensionbynumber().
// use descriptorpool to construct your own descriptors.
class libprotobuf_export fielddescriptor {
 public:
  // identifies a field type.  0 is reserved for errors.  the order is weird
  // for historical reasons.  types 12 and up are new in proto2.
  enum type {
    type_double         = 1,   // double, exactly eight bytes on the wire.
    type_float          = 2,   // float, exactly four bytes on the wire.
    type_int64          = 3,   // int64, varint on the wire.  negative numbers
                               // take 10 bytes.  use type_sint64 if negative
                               // values are likely.
    type_uint64         = 4,   // uint64, varint on the wire.
    type_int32          = 5,   // int32, varint on the wire.  negative numbers
                               // take 10 bytes.  use type_sint32 if negative
                               // values are likely.
    type_fixed64        = 6,   // uint64, exactly eight bytes on the wire.
    type_fixed32        = 7,   // uint32, exactly four bytes on the wire.
    type_bool           = 8,   // bool, varint on the wire.
    type_string         = 9,   // utf-8 text.
    type_group          = 10,  // tag-delimited message.  deprecated.
    type_message        = 11,  // length-delimited message.

    type_bytes          = 12,  // arbitrary byte array.
    type_uint32         = 13,  // uint32, varint on the wire
    type_enum           = 14,  // enum, varint on the wire
    type_sfixed32       = 15,  // int32, exactly four bytes on the wire
    type_sfixed64       = 16,  // int64, exactly eight bytes on the wire
    type_sint32         = 17,  // int32, zigzag-encoded varint on the wire
    type_sint64         = 18,  // int64, zigzag-encoded varint on the wire

    max_type            = 18,  // constant useful for defining lookup tables
                               // indexed by type.
  };

  // specifies the c++ data type used to represent the field.  there is a
  // fixed mapping from type to cpptype where each type maps to exactly one
  // cpptype.  0 is reserved for errors.
  enum cpptype {
    cpptype_int32       = 1,     // type_int32, type_sint32, type_sfixed32
    cpptype_int64       = 2,     // type_int64, type_sint64, type_sfixed64
    cpptype_uint32      = 3,     // type_uint32, type_fixed32
    cpptype_uint64      = 4,     // type_uint64, type_fixed64
    cpptype_double      = 5,     // type_double
    cpptype_float       = 6,     // type_float
    cpptype_bool        = 7,     // type_bool
    cpptype_enum        = 8,     // type_enum
    cpptype_string      = 9,     // type_string, type_bytes
    cpptype_message     = 10,    // type_message, type_group

    max_cpptype         = 10,    // constant useful for defining lookup tables
                                 // indexed by cpptype.
  };

  // identifies whether the field is optional, required, or repeated.  0 is
  // reserved for errors.
  enum label {
    label_optional      = 1,    // optional
    label_required      = 2,    // required
    label_repeated      = 3,    // repeated

    max_label           = 3,    // constant useful for defining lookup tables
                                // indexed by label.
  };

  // valid field numbers are positive integers up to kmaxnumber.
  static const int kmaxnumber = (1 << 29) - 1;

  // first field number reserved for the protocol buffer library implementation.
  // users may not declare fields that use reserved numbers.
  static const int kfirstreservednumber = 19000;
  // last field number reserved for the protocol buffer library implementation.
  // users may not declare fields that use reserved numbers.
  static const int klastreservednumber  = 19999;

  const string& name() const;        // name of this field within the message.
  const string& full_name() const;   // fully-qualified name of the field.
  const filedescriptor* file() const;// file in which this field was defined.
  bool is_extension() const;         // is this an extension field?
  int number() const;                // declared tag number.

  // same as name() except converted to lower-case.  this (and especially the
  // findfieldbylowercasename() method) can be useful when parsing formats
  // which prefer to use lowercase naming style.  (although, technically
  // field names should be lowercased anyway according to the protobuf style
  // guide, so this only makes a difference when dealing with old .proto files
  // which do not follow the guide.)
  const string& lowercase_name() const;

  // same as name() except converted to camel-case.  in this conversion, any
  // time an underscore appears in the name, it is removed and the next
  // letter is capitalized.  furthermore, the first letter of the name is
  // lower-cased.  examples:
  //   foobar -> foobar
  //   foo_bar -> foobar
  //   foobar -> foobar
  // this (and especially the findfieldbycamelcasename() method) can be useful
  // when parsing formats which prefer to use camel-case naming style.
  const string& camelcase_name() const;

  type type() const;                  // declared type of this field.
  const char* type_name() const;      // name of the declared type.
  cpptype cpp_type() const;           // c++ type of this field.
  const char* cpp_type_name() const;  // name of the c++ type.
  label label() const;                // optional/required/repeated

  bool is_required() const;      // shorthand for label() == label_required
  bool is_optional() const;      // shorthand for label() == label_optional
  bool is_repeated() const;      // shorthand for label() == label_repeated
  bool is_packable() const;      // shorthand for is_repeated() &&
                                 //               istypepackable(type())
  bool is_packed() const;        // shorthand for is_packable() &&
                                 //               options().packed()

  // index of this field within the message's field array, or the file or
  // extension scope's extensions array.
  int index() const;

  // does this field have an explicitly-declared default value?
  bool has_default_value() const;

  // get the field default value if cpp_type() == cpptype_int32.  if no
  // explicit default was defined, the default is 0.
  int32 default_value_int32() const;
  // get the field default value if cpp_type() == cpptype_int64.  if no
  // explicit default was defined, the default is 0.
  int64 default_value_int64() const;
  // get the field default value if cpp_type() == cpptype_uint32.  if no
  // explicit default was defined, the default is 0.
  uint32 default_value_uint32() const;
  // get the field default value if cpp_type() == cpptype_uint64.  if no
  // explicit default was defined, the default is 0.
  uint64 default_value_uint64() const;
  // get the field default value if cpp_type() == cpptype_float.  if no
  // explicit default was defined, the default is 0.0.
  float default_value_float() const;
  // get the field default value if cpp_type() == cpptype_double.  if no
  // explicit default was defined, the default is 0.0.
  double default_value_double() const;
  // get the field default value if cpp_type() == cpptype_bool.  if no
  // explicit default was defined, the default is false.
  bool default_value_bool() const;
  // get the field default value if cpp_type() == cpptype_enum.  if no
  // explicit default was defined, the default is the first value defined
  // in the enum type (all enum types are required to have at least one value).
  // this never returns null.
  const enumvaluedescriptor* default_value_enum() const;
  // get the field default value if cpp_type() == cpptype_string.  if no
  // explicit default was defined, the default is the empty string.
  const string& default_value_string() const;

  // the descriptor for the message of which this is a field.  for extensions,
  // this is the extended type.  never null.
  const descriptor* containing_type() const;

  // an extension may be declared within the scope of another message.  if this
  // field is an extension (is_extension() is true), then extension_scope()
  // returns that message, or null if the extension was declared at global
  // scope.  if this is not an extension, extension_scope() is undefined (may
  // assert-fail).
  const descriptor* extension_scope() const;

  // if type is type_message or type_group, returns a descriptor for the
  // message or the group type.  otherwise, undefined.
  const descriptor* message_type() const;
  // if type is type_enum, returns a descriptor for the enum.  otherwise,
  // undefined.
  const enumdescriptor* enum_type() const;

  // experimental; do not use.
  // if this field is a map field, experimental_map_key() is the field
  // that is the key for this map.
  // experimental_map_key()->containing_type() is the same as message_type().
  const fielddescriptor* experimental_map_key() const;

  // get the fieldoptions for this field.  this includes things listed in
  // square brackets after the field definition.  e.g., the field:
  //   optional string text = 1 [ctype=cord];
  // has the "ctype" option set.  allowed options are defined by fieldoptions
  // in google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const fieldoptions& options() const;

  // see descriptor::copyto().
  void copyto(fielddescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

  // helper method to get the cpptype for a particular type.
  static cpptype typetocpptype(type type);

  // return true iff [packed = true] is valid for fields of this type.
  static inline bool istypepackable(type field_type);

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this field declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef fieldoptions optionstype;

  // see descriptor::debugstring().
  void debugstring(int depth, string *contents) const;

  // formats the default value appropriately and returns it as a string.
  // must have a default value to call this. if quote_string_type is true, then
  // types of cpptype_string whill be surrounded by quotes and cescaped.
  string defaultvalueasstring(bool quote_string_type) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  const string* lowercase_name_;
  const string* camelcase_name_;
  const filedescriptor* file_;
  int number_;
  type type_;
  label label_;
  bool is_extension_;
  const descriptor* containing_type_;
  const descriptor* extension_scope_;
  const descriptor* message_type_;
  const enumdescriptor* enum_type_;
  const fielddescriptor* experimental_map_key_;
  const fieldoptions* options_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<fielddescriptor>() and allocatearray<fielddescriptor>() in
  // descriptor.cc and update them to initialize the field.

  bool has_default_value_;
  union {
    int32  default_value_int32_;
    int64  default_value_int64_;
    uint32 default_value_uint32_;
    uint64 default_value_uint64_;
    float  default_value_float_;
    double default_value_double_;
    bool   default_value_bool_;

    const enumvaluedescriptor* default_value_enum_;
    const string* default_value_string_;
  };

  static const cpptype ktypetocpptypemap[max_type + 1];

  static const char * const ktypetoname[max_type + 1];

  static const char * const kcpptypetoname[max_cpptype + 1];

  static const char * const klabeltoname[max_label + 1];

  // must be constructed using descriptorpool.
  fielddescriptor() {}
  friend class descriptorbuilder;
  friend class filedescriptor;
  friend class descriptor;
  google_disallow_evil_constructors(fielddescriptor);
};

// describes an enum type defined in a .proto file.  to get the enumdescriptor
// for a generated enum type, call typename_descriptor().  use descriptorpool
// to construct your own descriptors.
class libprotobuf_export enumdescriptor {
 public:
  // the name of this enum type in the containing scope.
  const string& name() const;

  // the fully-qualified name of the enum type, scope delimited by periods.
  const string& full_name() const;

  // index of this enum within the file or containing message's enum array.
  int index() const;

  // the .proto file in which this enum type was defined.  never null.
  const filedescriptor* file() const;

  // the number of values for this enumdescriptor.  guaranteed to be greater
  // than zero.
  int value_count() const;
  // gets a value by index, where 0 <= index < value_count().
  // these are returned in the order they were defined in the .proto file.
  const enumvaluedescriptor* value(int index) const;

  // looks up a value by name.  returns null if no such value exists.
  const enumvaluedescriptor* findvaluebyname(const string& name) const;
  // looks up a value by number.  returns null if no such value exists.  if
  // multiple values have this number, the first one defined is returned.
  const enumvaluedescriptor* findvaluebynumber(int number) const;

  // if this enum type is nested in a message type, this is that message type.
  // otherwise, null.
  const descriptor* containing_type() const;

  // get options for this enum type.  these are specified in the .proto file by
  // placing lines like "option foo = 1234;" in the enum definition.  allowed
  // options are defined by enumoptions in google/protobuf/descriptor.proto,
  // and any available extensions of that message.
  const enumoptions& options() const;

  // see descriptor::copyto().
  void copyto(enumdescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this enum declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef enumoptions optionstype;

  // see descriptor::debugstring().
  void debugstring(int depth, string *contents) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  const filedescriptor* file_;
  const descriptor* containing_type_;
  const enumoptions* options_;

  // true if this is a placeholder for an unknown type.
  bool is_placeholder_;
  // true if this is a placeholder and the type name wasn't fully-qualified.
  bool is_unqualified_placeholder_;

  int value_count_;
  enumvaluedescriptor* values_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<enumdescriptor>() and allocatearray<enumdescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // must be constructed using descriptorpool.
  enumdescriptor() {}
  friend class descriptorbuilder;
  friend class descriptor;
  friend class fielddescriptor;
  friend class enumvaluedescriptor;
  friend class filedescriptor;
  google_disallow_evil_constructors(enumdescriptor);
};

// describes an individual enum constant of a particular type.  to get the
// enumvaluedescriptor for a given enum value, first get the enumdescriptor
// for its type, then use enumdescriptor::findvaluebyname() or
// enumdescriptor::findvaluebynumber().  use descriptorpool to construct
// your own descriptors.
class libprotobuf_export enumvaluedescriptor {
 public:
  const string& name() const;  // name of this enum constant.
  int index() const;           // index within the enums's descriptor.
  int number() const;          // numeric value of this enum constant.

  // the full_name of an enum value is a sibling symbol of the enum type.
  // e.g. the full name of fielddescriptorproto::type_int32 is actually
  // "google.protobuf.fielddescriptorproto.type_int32", not
  // "google.protobuf.fielddescriptorproto.type.type_int32".  this is to conform
  // with c++ scoping rules for enums.
  const string& full_name() const;

  // the type of this value.  never null.
  const enumdescriptor* type() const;

  // get options for this enum value.  these are specified in the .proto file
  // by adding text like "[foo = 1234]" after an enum value definition.
  // allowed options are defined by enumvalueoptions in
  // google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const enumvalueoptions& options() const;

  // see descriptor::copyto().
  void copyto(enumvaluedescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this enum value declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef enumvalueoptions optionstype;

  // see descriptor::debugstring().
  void debugstring(int depth, string *contents) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  int number_;
  const enumdescriptor* type_;
  const enumvalueoptions* options_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<enumvaluedescriptor>() and allocatearray<enumvaluedescriptor>()
  // in descriptor.cc and update them to initialize the field.

  // must be constructed using descriptorpool.
  enumvaluedescriptor() {}
  friend class descriptorbuilder;
  friend class enumdescriptor;
  google_disallow_evil_constructors(enumvaluedescriptor);
};

// describes an rpc service.  to get the servicedescriptor for a service,
// call service::getdescriptor().  generated service classes also have a
// static method called descriptor() which returns the type's
// servicedescriptor.  use descriptorpool to construct your own descriptors.
class libprotobuf_export servicedescriptor {
 public:
  // the name of the service, not including its containing scope.
  const string& name() const;
  // the fully-qualified name of the service, scope delimited by periods.
  const string& full_name() const;
  // index of this service within the file's services array.
  int index() const;

  // the .proto file in which this service was defined.  never null.
  const filedescriptor* file() const;

  // get options for this service type.  these are specified in the .proto file
  // by placing lines like "option foo = 1234;" in the service definition.
  // allowed options are defined by serviceoptions in
  // google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const serviceoptions& options() const;

  // the number of methods this service defines.
  int method_count() const;
  // gets a methoddescriptor by index, where 0 <= index < method_count().
  // these are returned in the order they were defined in the .proto file.
  const methoddescriptor* method(int index) const;

  // look up a methoddescriptor by name.
  const methoddescriptor* findmethodbyname(const string& name) const;
  // see descriptor::copyto().
  void copyto(servicedescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this service declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef serviceoptions optionstype;

  // see descriptor::debugstring().
  void debugstring(string *contents) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  const filedescriptor* file_;
  const serviceoptions* options_;
  int method_count_;
  methoddescriptor* methods_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<servicedescriptor>() and allocatearray<servicedescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // must be constructed using descriptorpool.
  servicedescriptor() {}
  friend class descriptorbuilder;
  friend class filedescriptor;
  friend class methoddescriptor;
  google_disallow_evil_constructors(servicedescriptor);
};

// describes an individual service method.  to obtain a methoddescriptor given
// a service, first get its servicedescriptor, then call
// servicedescriptor::findmethodbyname().  use descriptorpool to construct your
// own descriptors.
class libprotobuf_export methoddescriptor {
 public:
  // name of this method, not including containing scope.
  const string& name() const;
  // the fully-qualified name of the method, scope delimited by periods.
  const string& full_name() const;
  // index within the service's descriptor.
  int index() const;

  // gets the service to which this method belongs.  never null.
  const servicedescriptor* service() const;

  // gets the type of protocol message which this method accepts as input.
  const descriptor* input_type() const;
  // gets the type of protocol message which this message produces as output.
  const descriptor* output_type() const;

  // get options for this method.  these are specified in the .proto file by
  // placing lines like "option foo = 1234;" in curly-braces after a method
  // declaration.  allowed options are defined by methodoptions in
  // google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const methodoptions& options() const;

  // see descriptor::copyto().
  void copyto(methoddescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of this method declaration.  returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool getsourcelocation(sourcelocation* out_location) const;

 private:
  typedef methodoptions optionstype;

  // see descriptor::debugstring().
  void debugstring(int depth, string *contents) const;

  // walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void getlocationpath(vector<int>* output) const;

  const string* name_;
  const string* full_name_;
  const servicedescriptor* service_;
  const descriptor* input_type_;
  const descriptor* output_type_;
  const methodoptions* options_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<methoddescriptor>() and allocatearray<methoddescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // must be constructed using descriptorpool.
  methoddescriptor() {}
  friend class descriptorbuilder;
  friend class servicedescriptor;
  google_disallow_evil_constructors(methoddescriptor);
};


// describes a whole .proto file.  to get the filedescriptor for a compiled-in
// file, get the descriptor for something defined in that file and call
// descriptor->file().  use descriptorpool to construct your own descriptors.
class libprotobuf_export filedescriptor {
 public:
  // the filename, relative to the source tree.
  // e.g. "google/protobuf/descriptor.proto"
  const string& name() const;

  // the package, e.g. "google.protobuf.compiler".
  const string& package() const;

  // the descriptorpool in which this filedescriptor and all its contents were
  // allocated.  never null.
  const descriptorpool* pool() const;

  // the number of files imported by this one.
  int dependency_count() const;
  // gets an imported file by index, where 0 <= index < dependency_count().
  // these are returned in the order they were defined in the .proto file.
  const filedescriptor* dependency(int index) const;

  // the number of files public imported by this one.
  // the public dependency list is a subset of the dependency list.
  int public_dependency_count() const;
  // gets a public imported file by index, where 0 <= index <
  // public_dependency_count().
  // these are returned in the order they were defined in the .proto file.
  const filedescriptor* public_dependency(int index) const;

  // the number of files that are imported for weak fields.
  // the weak dependency list is a subset of the dependency list.
  int weak_dependency_count() const;
  // gets a weak imported file by index, where 0 <= index <
  // weak_dependency_count().
  // these are returned in the order they were defined in the .proto file.
  const filedescriptor* weak_dependency(int index) const;

  // number of top-level message types defined in this file.  (this does not
  // include nested types.)
  int message_type_count() const;
  // gets a top-level message type, where 0 <= index < message_type_count().
  // these are returned in the order they were defined in the .proto file.
  const descriptor* message_type(int index) const;

  // number of top-level enum types defined in this file.  (this does not
  // include nested types.)
  int enum_type_count() const;
  // gets a top-level enum type, where 0 <= index < enum_type_count().
  // these are returned in the order they were defined in the .proto file.
  const enumdescriptor* enum_type(int index) const;

  // number of services defined in this file.
  int service_count() const;
  // gets a service, where 0 <= index < service_count().
  // these are returned in the order they were defined in the .proto file.
  const servicedescriptor* service(int index) const;

  // number of extensions defined at file scope.  (this does not include
  // extensions nested within message types.)
  int extension_count() const;
  // gets an extension's descriptor, where 0 <= index < extension_count().
  // these are returned in the order they were defined in the .proto file.
  const fielddescriptor* extension(int index) const;

  // get options for this file.  these are specified in the .proto file by
  // placing lines like "option foo = 1234;" at the top level, outside of any
  // other definitions.  allowed options are defined by fileoptions in
  // google/protobuf/descriptor.proto, and any available extensions of that
  // message.
  const fileoptions& options() const;

  // find a top-level message type by name.  returns null if not found.
  const descriptor* findmessagetypebyname(const string& name) const;
  // find a top-level enum type by name.  returns null if not found.
  const enumdescriptor* findenumtypebyname(const string& name) const;
  // find an enum value defined in any top-level enum by name.  returns null if
  // not found.
  const enumvaluedescriptor* findenumvaluebyname(const string& name) const;
  // find a service definition by name.  returns null if not found.
  const servicedescriptor* findservicebyname(const string& name) const;
  // find a top-level extension definition by name.  returns null if not found.
  const fielddescriptor* findextensionbyname(const string& name) const;
  // similar to findextensionbyname(), but searches by lowercased-name.  see
  // descriptor::findfieldbylowercasename().
  const fielddescriptor* findextensionbylowercasename(const string& name) const;
  // similar to findextensionbyname(), but searches by camelcased-name.  see
  // descriptor::findfieldbycamelcasename().
  const fielddescriptor* findextensionbycamelcasename(const string& name) const;

  // see descriptor::copyto().
  // notes:
  // - this method does not copy source code information since it is relatively
  //   large and rarely needed.  see copysourcecodeinfoto() below.
  void copyto(filedescriptorproto* proto) const;
  // write the source code information of this filedescriptor into the given
  // filedescriptorproto.  see copyto() above.
  void copysourcecodeinfoto(filedescriptorproto* proto) const;

  // see descriptor::debugstring().
  string debugstring() const;

 private:
  // source location ---------------------------------------------------

  // updates |*out_location| to the source location of the complete
  // extent of the declaration or declaration-part denoted by |path|.
  // returns false and leaves |*out_location| unchanged iff location
  // information was not available.  (see sourcecodeinfo for
  // description of path encoding.)
  bool getsourcelocation(const vector<int>& path,
                         sourcelocation* out_location) const;

  typedef fileoptions optionstype;

  const string* name_;
  const string* package_;
  const descriptorpool* pool_;
  int dependency_count_;
  const filedescriptor** dependencies_;
  int public_dependency_count_;
  int* public_dependencies_;
  int weak_dependency_count_;
  int* weak_dependencies_;
  int message_type_count_;
  descriptor* message_types_;
  int enum_type_count_;
  enumdescriptor* enum_types_;
  int service_count_;
  servicedescriptor* services_;
  int extension_count_;
  fielddescriptor* extensions_;
  const fileoptions* options_;

  const filedescriptortables* tables_;
  const sourcecodeinfo* source_code_info_;
  // important:  if you add a new field, make sure to search for all instances
  // of allocate<filedescriptor>() and allocatearray<filedescriptor>() in
  // descriptor.cc and update them to initialize the field.

  filedescriptor() {}
  friend class descriptorbuilder;
  friend class descriptor;
  friend class fielddescriptor;
  friend class enumdescriptor;
  friend class enumvaluedescriptor;
  friend class methoddescriptor;
  friend class servicedescriptor;
  google_disallow_evil_constructors(filedescriptor);
};

// ===================================================================

// used to construct descriptors.
//
// normally you won't want to build your own descriptors.  message classes
// constructed by the protocol compiler will provide them for you.  however,
// if you are implementing message on your own, or if you are writing a
// program which can operate on totally arbitrary types and needs to load
// them from some sort of database, you might need to.
//
// since descriptors are composed of a whole lot of cross-linked bits of
// data that would be a pain to put together manually, the
// descriptorpool class is provided to make the process easier.  it can
// take a filedescriptorproto (defined in descriptor.proto), validate it,
// and convert it to a set of nicely cross-linked descriptors.
//
// descriptorpool also helps with memory management.  descriptors are
// composed of many objects containing static data and pointers to each
// other.  in all likelihood, when it comes time to delete this data,
// you'll want to delete it all at once.  in fact, it is not uncommon to
// have a whole pool of descriptors all cross-linked with each other which
// you wish to delete all at once.  this class represents such a pool, and
// handles the memory management for you.
//
// you can also search for descriptors within a descriptorpool by name, and
// extensions by number.
class libprotobuf_export descriptorpool {
 public:
  // create a normal, empty descriptorpool.
  descriptorpool();

  // constructs a descriptorpool that, when it can't find something among the
  // descriptors already in the pool, looks for it in the given
  // descriptordatabase.
  // notes:
  // - if a descriptorpool is constructed this way, its buildfile*() methods
  //   must not be called (they will assert-fail).  the only way to populate
  //   the pool with descriptors is to call the find*by*() methods.
  // - the find*by*() methods may block the calling thread if the
  //   descriptordatabase blocks.  this in turn means that parsing messages
  //   may block if they need to look up extensions.
  // - the find*by*() methods will use mutexes for thread-safety, thus making
  //   them slower even when they don't have to fall back to the database.
  //   in fact, even the find*by*() methods of descriptor objects owned by
  //   this pool will be slower, since they will have to obtain locks too.
  // - an errorcollector may optionally be given to collect validation errors
  //   in files loaded from the database.  if not given, errors will be printed
  //   to google_log(error).  remember that files are built on-demand, so this
  //   errorcollector may be called from any thread that calls one of the
  //   find*by*() methods.
  class errorcollector;
  explicit descriptorpool(descriptordatabase* fallback_database,
                          errorcollector* error_collector = null);

  ~descriptorpool();

  // get a pointer to the generated pool.  generated protocol message classes
  // which are compiled into the binary will allocate their descriptors in
  // this pool.  do not add your own descriptors to this pool.
  static const descriptorpool* generated_pool();

  // find a filedescriptor in the pool by file name.  returns null if not
  // found.
  const filedescriptor* findfilebyname(const string& name) const;

  // find the filedescriptor in the pool which defines the given symbol.
  // if any of the find*byname() methods below would succeed, then this is
  // equivalent to calling that method and calling the result's file() method.
  // otherwise this returns null.
  const filedescriptor* findfilecontainingsymbol(
      const string& symbol_name) const;

  // looking up descriptors ------------------------------------------
  // these find descriptors by fully-qualified name.  these will find both
  // top-level descriptors and nested descriptors.  they return null if not
  // found.

  const descriptor* findmessagetypebyname(const string& name) const;
  const fielddescriptor* findfieldbyname(const string& name) const;
  const fielddescriptor* findextensionbyname(const string& name) const;
  const enumdescriptor* findenumtypebyname(const string& name) const;
  const enumvaluedescriptor* findenumvaluebyname(const string& name) const;
  const servicedescriptor* findservicebyname(const string& name) const;
  const methoddescriptor* findmethodbyname(const string& name) const;

  // finds an extension of the given type by number.  the extendee must be
  // a member of this descriptorpool or one of its underlays.
  const fielddescriptor* findextensionbynumber(const descriptor* extendee,
                                               int number) const;

  // finds extensions of extendee. the extensions will be appended to
  // out in an undefined order. only extensions defined directly in
  // this descriptorpool or one of its underlays are guaranteed to be
  // found: extensions defined in the fallback database might not be found
  // depending on the database implementation.
  void findallextensions(const descriptor* extendee,
                         vector<const fielddescriptor*>* out) const;

  // building descriptors --------------------------------------------

  // when converting a filedescriptorproto to a filedescriptor, various
  // errors might be detected in the input.  the caller may handle these
  // programmatically by implementing an errorcollector.
  class libprotobuf_export errorcollector {
   public:
    inline errorcollector() {}
    virtual ~errorcollector();

    // these constants specify what exact part of the construct is broken.
    // this is useful e.g. for mapping the error back to an exact location
    // in a .proto file.
    enum errorlocation {
      name,              // the symbol name, or the package name for files
      number,            // field or extension range number
      type,              // field type
      extendee,          // field extendee
      default_value,     // field default value
      input_type,        // method input type
      output_type,       // method output type
      option_name,       // name in assignment
      option_value,      // value in option assignment
      other              // some other problem
    };

    // reports an error in the filedescriptorproto.
    virtual void adderror(
      const string& filename,      // file name in which the error occurred.
      const string& element_name,  // full name of the erroneous element.
      const message* descriptor,   // descriptor of the erroneous element.
      errorlocation location,      // one of the location constants, above.
      const string& message        // human-readable error message.
      ) = 0;

   private:
    google_disallow_evil_constructors(errorcollector);
  };

  // convert the filedescriptorproto to real descriptors and place them in
  // this descriptorpool.  all dependencies of the file must already be in
  // the pool.  returns the resulting filedescriptor, or null if there were
  // problems with the input (e.g. the message was invalid, or dependencies
  // were missing).  details about the errors are written to google_log(error).
  const filedescriptor* buildfile(const filedescriptorproto& proto);

  // same as buildfile() except errors are sent to the given errorcollector.
  const filedescriptor* buildfilecollectingerrors(
    const filedescriptorproto& proto,
    errorcollector* error_collector);

  // by default, it is an error if a filedescriptorproto contains references
  // to types or other files that are not found in the descriptorpool (or its
  // backing descriptordatabase, if any).  if you call
  // allowunknowndependencies(), however, then unknown types and files
  // will be replaced by placeholder descriptors.  this can allow you to
  // perform some useful operations with a .proto file even if you do not
  // have access to other .proto files on which it depends.  however, some
  // heuristics must be used to fill in the gaps in information, and these
  // can lead to descriptors which are inaccurate.  for example, the
  // descriptorpool may be forced to guess whether an unknown type is a message
  // or an enum, as well as what package it resides in.  furthermore,
  // placeholder types will not be discoverable via findmessagetypebyname()
  // and similar methods, which could confuse some descriptor-based algorithms.
  // generally, the results of this option should only be relied upon for
  // debugging purposes.
  void allowunknowndependencies() { allow_unknown_ = true; }

  // internal stuff --------------------------------------------------
  // these methods must not be called from outside the proto2 library.
  // these methods may contain hidden pitfalls and may be removed in a
  // future library version.

  // create a descriptorpool which is overlaid on top of some other pool.
  // if you search for a descriptor in the overlay and it is not found, the
  // underlay will be searched as a backup.  if the underlay has its own
  // underlay, that will be searched next, and so on.  this also means that
  // files built in the overlay will be cross-linked with the underlay's
  // descriptors if necessary.  the underlay remains property of the caller;
  // it must remain valid for the lifetime of the newly-constructed pool.
  //
  // example:  say you want to parse a .proto file at runtime in order to use
  // its type with a dynamicmessage.  say this .proto file has dependencies,
  // but you know that all the dependencies will be things that are already
  // compiled into the binary.  for ease of use, you'd like to load the types
  // right out of generated_pool() rather than have to parse redundant copies
  // of all these .protos and runtime.  but, you don't want to add the parsed
  // types directly into generated_pool(): this is not allowed, and would be
  // bad design anyway.  so, instead, you could use generated_pool() as an
  // underlay for a new descriptorpool in which you add only the new file.
  //
  // warning:  use of underlays can lead to many subtle gotchas.  instead,
  //   try to formulate what you want to do in terms of descriptordatabases.
  explicit descriptorpool(const descriptorpool* underlay);

  // called by generated classes at init time to add their descriptors to
  // generated_pool.  do not call this in your own code!  filename must be a
  // permanent string (e.g. a string literal).
  static void internaladdgeneratedfile(
      const void* encoded_file_descriptor, int size);


  // for internal use only:  gets a non-const pointer to the generated pool.
  // this is called at static-initialization time only, so thread-safety is
  // not a concern.  if both an underlay and a fallback database are present,
  // the underlay takes precedence.
  static descriptorpool* internal_generated_pool();

  // for internal use only:  changes the behavior of buildfile() such that it
  // allows the file to make reference to message types declared in other files
  // which it did not officially declare as dependencies.
  void internaldontenforcedependencies();

  // for internal use only.
  void internal_set_underlay(const descriptorpool* underlay) {
    underlay_ = underlay;
  }

  // for internal (unit test) use only:  returns true if a filedescriptor has
  // been constructed for the given file, false otherwise.  useful for testing
  // lazy descriptor initialization behavior.
  bool internalisfileloaded(const string& filename) const;

 private:
  friend class descriptor;
  friend class fielddescriptor;
  friend class enumdescriptor;
  friend class servicedescriptor;
  friend class filedescriptor;
  friend class descriptorbuilder;

  // return true if the given name is a sub-symbol of any non-package
  // descriptor that already exists in the descriptor pool.  (the full
  // definition of such types is already known.)
  bool issubsymbolofbuilttype(const string& name) const;

  // tries to find something in the fallback database and link in the
  // corresponding proto file.  returns true if successful, in which case
  // the caller should search for the thing again.  these are declared
  // const because they are called by (semantically) const methods.
  bool tryfindfileinfallbackdatabase(const string& name) const;
  bool tryfindsymbolinfallbackdatabase(const string& name) const;
  bool tryfindextensioninfallbackdatabase(const descriptor* containing_type,
                                          int field_number) const;

  // like buildfile() but called internally when the file has been loaded from
  // fallback_database_.  declared const because it is called by (semantically)
  // const methods.
  const filedescriptor* buildfilefromdatabase(
    const filedescriptorproto& proto) const;

  // if fallback_database_ is null, this is null.  otherwise, this is a mutex
  // which must be locked while accessing tables_.
  mutex* mutex_;

  // see constructor.
  descriptordatabase* fallback_database_;
  errorcollector* default_error_collector_;
  const descriptorpool* underlay_;

  // this class contains a lot of hash maps with complicated types that
  // we'd like to keep out of the header.
  class tables;
  scoped_ptr<tables> tables_;

  bool enforce_dependencies_;
  bool allow_unknown_;

  google_disallow_evil_constructors(descriptorpool);
};

// inline methods ====================================================

// these macros makes this repetitive code more readable.
#define protobuf_define_accessor(class, field, type) \
  inline type class::field() const { return field##_; }

// strings fields are stored as pointers but returned as const references.
#define protobuf_define_string_accessor(class, field) \
  inline const string& class::field() const { return *field##_; }

// arrays take an index parameter, obviously.
#define protobuf_define_array_accessor(class, field, type) \
  inline type class::field(int index) const { return field##s_ + index; }

#define protobuf_define_options_accessor(class, type) \
  inline const type& class::options() const { return *options_; }

protobuf_define_string_accessor(descriptor, name)
protobuf_define_string_accessor(descriptor, full_name)
protobuf_define_accessor(descriptor, file, const filedescriptor*)
protobuf_define_accessor(descriptor, containing_type, const descriptor*)

protobuf_define_accessor(descriptor, field_count, int)
protobuf_define_accessor(descriptor, nested_type_count, int)
protobuf_define_accessor(descriptor, enum_type_count, int)

protobuf_define_array_accessor(descriptor, field, const fielddescriptor*)
protobuf_define_array_accessor(descriptor, nested_type, const descriptor*)
protobuf_define_array_accessor(descriptor, enum_type, const enumdescriptor*)

protobuf_define_accessor(descriptor, extension_range_count, int)
protobuf_define_accessor(descriptor, extension_count, int)
protobuf_define_array_accessor(descriptor, extension_range,
                               const descriptor::extensionrange*)
protobuf_define_array_accessor(descriptor, extension,
                               const fielddescriptor*)
protobuf_define_options_accessor(descriptor, messageoptions)

protobuf_define_string_accessor(fielddescriptor, name)
protobuf_define_string_accessor(fielddescriptor, full_name)
protobuf_define_string_accessor(fielddescriptor, lowercase_name)
protobuf_define_string_accessor(fielddescriptor, camelcase_name)
protobuf_define_accessor(fielddescriptor, file, const filedescriptor*)
protobuf_define_accessor(fielddescriptor, number, int)
protobuf_define_accessor(fielddescriptor, is_extension, bool)
protobuf_define_accessor(fielddescriptor, type, fielddescriptor::type)
protobuf_define_accessor(fielddescriptor, label, fielddescriptor::label)
protobuf_define_accessor(fielddescriptor, containing_type, const descriptor*)
protobuf_define_accessor(fielddescriptor, extension_scope, const descriptor*)
protobuf_define_accessor(fielddescriptor, message_type, const descriptor*)
protobuf_define_accessor(fielddescriptor, enum_type, const enumdescriptor*)
protobuf_define_accessor(fielddescriptor, experimental_map_key,
                         const fielddescriptor*)
protobuf_define_options_accessor(fielddescriptor, fieldoptions)
protobuf_define_accessor(fielddescriptor, has_default_value, bool)
protobuf_define_accessor(fielddescriptor, default_value_int32 , int32 )
protobuf_define_accessor(fielddescriptor, default_value_int64 , int64 )
protobuf_define_accessor(fielddescriptor, default_value_uint32, uint32)
protobuf_define_accessor(fielddescriptor, default_value_uint64, uint64)
protobuf_define_accessor(fielddescriptor, default_value_float , float )
protobuf_define_accessor(fielddescriptor, default_value_double, double)
protobuf_define_accessor(fielddescriptor, default_value_bool  , bool  )
protobuf_define_accessor(fielddescriptor, default_value_enum,
                         const enumvaluedescriptor*)
protobuf_define_string_accessor(fielddescriptor, default_value_string)

protobuf_define_string_accessor(enumdescriptor, name)
protobuf_define_string_accessor(enumdescriptor, full_name)
protobuf_define_accessor(enumdescriptor, file, const filedescriptor*)
protobuf_define_accessor(enumdescriptor, containing_type, const descriptor*)
protobuf_define_accessor(enumdescriptor, value_count, int)
protobuf_define_array_accessor(enumdescriptor, value,
                               const enumvaluedescriptor*)
protobuf_define_options_accessor(enumdescriptor, enumoptions)

protobuf_define_string_accessor(enumvaluedescriptor, name)
protobuf_define_string_accessor(enumvaluedescriptor, full_name)
protobuf_define_accessor(enumvaluedescriptor, number, int)
protobuf_define_accessor(enumvaluedescriptor, type, const enumdescriptor*)
protobuf_define_options_accessor(enumvaluedescriptor, enumvalueoptions)

protobuf_define_string_accessor(servicedescriptor, name)
protobuf_define_string_accessor(servicedescriptor, full_name)
protobuf_define_accessor(servicedescriptor, file, const filedescriptor*)
protobuf_define_accessor(servicedescriptor, method_count, int)
protobuf_define_array_accessor(servicedescriptor, method,
                               const methoddescriptor*)
protobuf_define_options_accessor(servicedescriptor, serviceoptions)

protobuf_define_string_accessor(methoddescriptor, name)
protobuf_define_string_accessor(methoddescriptor, full_name)
protobuf_define_accessor(methoddescriptor, service, const servicedescriptor*)
protobuf_define_accessor(methoddescriptor, input_type, const descriptor*)
protobuf_define_accessor(methoddescriptor, output_type, const descriptor*)
protobuf_define_options_accessor(methoddescriptor, methodoptions)
protobuf_define_string_accessor(filedescriptor, name)
protobuf_define_string_accessor(filedescriptor, package)
protobuf_define_accessor(filedescriptor, pool, const descriptorpool*)
protobuf_define_accessor(filedescriptor, dependency_count, int)
protobuf_define_accessor(filedescriptor, public_dependency_count, int)
protobuf_define_accessor(filedescriptor, weak_dependency_count, int)
protobuf_define_accessor(filedescriptor, message_type_count, int)
protobuf_define_accessor(filedescriptor, enum_type_count, int)
protobuf_define_accessor(filedescriptor, service_count, int)
protobuf_define_accessor(filedescriptor, extension_count, int)
protobuf_define_options_accessor(filedescriptor, fileoptions)

protobuf_define_array_accessor(filedescriptor, message_type, const descriptor*)
protobuf_define_array_accessor(filedescriptor, enum_type, const enumdescriptor*)
protobuf_define_array_accessor(filedescriptor, service,
                               const servicedescriptor*)
protobuf_define_array_accessor(filedescriptor, extension,
                               const fielddescriptor*)

#undef protobuf_define_accessor
#undef protobuf_define_string_accessor
#undef protobuf_define_array_accessor

// a few accessors differ from the macros...

inline bool fielddescriptor::is_required() const {
  return label() == label_required;
}

inline bool fielddescriptor::is_optional() const {
  return label() == label_optional;
}

inline bool fielddescriptor::is_repeated() const {
  return label() == label_repeated;
}

inline bool fielddescriptor::is_packable() const {
  return is_repeated() && istypepackable(type());
}

// to save space, index() is computed by looking at the descriptor's position
// in the parent's array of children.
inline int fielddescriptor::index() const {
  if (!is_extension_) {
    return this - containing_type_->fields_;
  } else if (extension_scope_ != null) {
    return this - extension_scope_->extensions_;
  } else {
    return this - file_->extensions_;
  }
}

inline int descriptor::index() const {
  if (containing_type_ == null) {
    return this - file_->message_types_;
  } else {
    return this - containing_type_->nested_types_;
  }
}

inline int enumdescriptor::index() const {
  if (containing_type_ == null) {
    return this - file_->enum_types_;
  } else {
    return this - containing_type_->enum_types_;
  }
}

inline int enumvaluedescriptor::index() const {
  return this - type_->values_;
}

inline int servicedescriptor::index() const {
  return this - file_->services_;
}

inline int methoddescriptor::index() const {
  return this - service_->methods_;
}

inline const char* fielddescriptor::type_name() const {
  return ktypetoname[type_];
}

inline fielddescriptor::cpptype fielddescriptor::cpp_type() const {
  return ktypetocpptypemap[type_];
}

inline const char* fielddescriptor::cpp_type_name() const {
  return kcpptypetoname[ktypetocpptypemap[type_]];
}

inline fielddescriptor::cpptype fielddescriptor::typetocpptype(type type) {
  return ktypetocpptypemap[type];
}

inline bool fielddescriptor::istypepackable(type field_type) {
  return (field_type != fielddescriptor::type_string &&
          field_type != fielddescriptor::type_group &&
          field_type != fielddescriptor::type_message &&
          field_type != fielddescriptor::type_bytes);
}

inline const filedescriptor* filedescriptor::dependency(int index) const {
  return dependencies_[index];
}

inline const filedescriptor* filedescriptor::public_dependency(
    int index) const {
  return dependencies_[public_dependencies_[index]];
}

inline const filedescriptor* filedescriptor::weak_dependency(
    int index) const {
  return dependencies_[weak_dependencies_[index]];
}

}  // namespace protobuf

}  // namespace google
#endif  // google_protobuf_descriptor_h__
