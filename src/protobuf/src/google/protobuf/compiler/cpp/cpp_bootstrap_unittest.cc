// protocol buffers - google's data interchange format
// copyright 2008 google inc.  all rights reserved.
// http://code.google.com/p/protobuf/
//
// redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * neither the name of google inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// this software is provided by the copyright holders and contributors
// "as is" and any express or implied warranties, including, but not
// limited to, the implied warranties of merchantability and fitness for
// a particular purpose are disclaimed. in no event shall the copyright
// owner or contributors be liable for any direct, indirect, incidental,
// special, exemplary, or consequential damages (including, but not
// limited to, procurement of substitute goods or services; loss of use,
// data, or profits; or business interruption) however caused and on any
// theory of liability, whether in contract, strict liability, or tort
// (including negligence or otherwise) arising in any way out of the use
// of this software, even if advised of the possibility of such damage.

// author: kenton@google.com (kenton varda)
//  based on original protocol buffers design by
//  sanjay ghemawat, jeff dean, and others.
//
// this test insures that google/protobuf/descriptor.pb.{h,cc} match exactly
// what would be generated by the protocol compiler.  these files are not
// generated automatically at build time because they are compiled into the
// protocol compiler itself.  so, if they were auto-generated, you'd have a
// chicken-and-egg problem.
//
// if this test fails, run the script
// "generate_descriptor_proto.sh" and add
// descriptor.pb.{h,cc} to your changelist.

#include <map>

#include <google/protobuf/compiler/cpp/cpp_generator.h>
#include <google/protobuf/compiler/importer.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
#include <google/protobuf/stubs/map-util.h>
#include <google/protobuf/stubs/stl_util.h>
#include <google/protobuf/stubs/strutil.h>
#include <google/protobuf/stubs/substitute.h>

#include <google/protobuf/testing/file.h>
#include <google/protobuf/testing/googletest.h>
#include <gtest/gtest.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace cpp {

namespace {

class mockerrorcollector : public multifileerrorcollector {
 public:
  mockerrorcollector() {}
  ~mockerrorcollector() {}

  string text_;

  // implements errorcollector ---------------------------------------
  void adderror(const string& filename, int line, int column,
                const string& message) {
    strings::substituteandappend(&text_, "$0:$1:$2: $3\n",
                                 filename, line, column, message);
  }
};

class mockgeneratorcontext : public generatorcontext {
 public:
  mockgeneratorcontext() {}
  ~mockgeneratorcontext() {
    stldeletevalues(&files_);
  }

  void expectfilematches(const string& virtual_filename,
                         const string& physical_filename) {
    string* expected_contents = findptrornull(files_, virtual_filename);
    assert_true(expected_contents != null)
      << "generator failed to generate file: " << virtual_filename;

    string actual_contents;
    file::readfiletostringordie(
      testsourcedir() + "/" + physical_filename,
      &actual_contents);
    expect_true(actual_contents == *expected_contents)
      << physical_filename << " needs to be regenerated.  please run "
         "generate_descriptor_proto.sh and add this file "
         "to your cl.";
  }

  // implements generatorcontext --------------------------------------

  virtual io::zerocopyoutputstream* open(const string& filename) {
    string** map_slot = &files_[filename];
    if (*map_slot != null) delete *map_slot;
    *map_slot = new string;

    return new io::stringoutputstream(*map_slot);
  }

 private:
  map<string, string*> files_;
};

test(bootstraptest, generateddescriptormatches) {
  mockerrorcollector error_collector;
  disksourcetree source_tree;
  source_tree.mappath("", testsourcedir());
  importer importer(&source_tree, &error_collector);
  const filedescriptor* proto_file =
    importer.import("google/protobuf/descriptor.proto");
  const filedescriptor* plugin_proto_file =
    importer.import("google/protobuf/compiler/plugin.proto");
  expect_eq("", error_collector.text_);
  assert_true(proto_file != null);
  assert_true(plugin_proto_file != null);

  cppgenerator generator;
  mockgeneratorcontext context;
  string error;
  string parameter;
  parameter = "dllexport_decl=libprotobuf_export";
  assert_true(generator.generate(proto_file, parameter,
                                 &context, &error));
  parameter = "dllexport_decl=libprotoc_export";
  assert_true(generator.generate(plugin_proto_file, parameter,
                                 &context, &error));

  context.expectfilematches("google/protobuf/descriptor.pb.h",
                            "google/protobuf/descriptor.pb.h");
  context.expectfilematches("google/protobuf/descriptor.pb.cc",
                            "google/protobuf/descriptor.pb.cc");
  context.expectfilematches("google/protobuf/compiler/plugin.pb.h",
                            "google/protobuf/compiler/plugin.pb.h");
  context.expectfilematches("google/protobuf/compiler/plugin.pb.cc",
                            "google/protobuf/compiler/plugin.pb.cc");
}

}  // namespace

}  // namespace cpp
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
