// generated by the protocol buffer compiler.  do not edit!
// source: google/protobuf/descriptor.proto

#ifndef protobuf_google_2fprotobuf_2fdescriptor_2eproto__included
#define protobuf_google_2fprotobuf_2fdescriptor_2eproto__included

#include <string>

#include <google/protobuf/stubs/common.h>

#if google_protobuf_version < 2005001
#error this file was generated by a newer version of protoc which is
#error incompatible with your protocol buffer headers.  please update
#error your headers.
#endif
#if 2005001 < google_protobuf_min_protoc_version
#error this file was generated by an older version of protoc which is
#error incompatible with your protocol buffer headers.  please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace google {
namespace protobuf {

// internal implementation detail -- do not call these.
void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

class filedescriptorset;
class filedescriptorproto;
class descriptorproto;
class descriptorproto_extensionrange;
class fielddescriptorproto;
class enumdescriptorproto;
class enumvaluedescriptorproto;
class servicedescriptorproto;
class methoddescriptorproto;
class fileoptions;
class messageoptions;
class fieldoptions;
class enumoptions;
class enumvalueoptions;
class serviceoptions;
class methodoptions;
class uninterpretedoption;
class uninterpretedoption_namepart;
class sourcecodeinfo;
class sourcecodeinfo_location;

enum fielddescriptorproto_type {
  fielddescriptorproto_type_type_double = 1,
  fielddescriptorproto_type_type_float = 2,
  fielddescriptorproto_type_type_int64 = 3,
  fielddescriptorproto_type_type_uint64 = 4,
  fielddescriptorproto_type_type_int32 = 5,
  fielddescriptorproto_type_type_fixed64 = 6,
  fielddescriptorproto_type_type_fixed32 = 7,
  fielddescriptorproto_type_type_bool = 8,
  fielddescriptorproto_type_type_string = 9,
  fielddescriptorproto_type_type_group = 10,
  fielddescriptorproto_type_type_message = 11,
  fielddescriptorproto_type_type_bytes = 12,
  fielddescriptorproto_type_type_uint32 = 13,
  fielddescriptorproto_type_type_enum = 14,
  fielddescriptorproto_type_type_sfixed32 = 15,
  fielddescriptorproto_type_type_sfixed64 = 16,
  fielddescriptorproto_type_type_sint32 = 17,
  fielddescriptorproto_type_type_sint64 = 18
};
libprotobuf_export bool fielddescriptorproto_type_isvalid(int value);
const fielddescriptorproto_type fielddescriptorproto_type_type_min = fielddescriptorproto_type_type_double;
const fielddescriptorproto_type fielddescriptorproto_type_type_max = fielddescriptorproto_type_type_sint64;
const int fielddescriptorproto_type_type_arraysize = fielddescriptorproto_type_type_max + 1;

libprotobuf_export const ::google::protobuf::enumdescriptor* fielddescriptorproto_type_descriptor();
inline const ::std::string& fielddescriptorproto_type_name(fielddescriptorproto_type value) {
  return ::google::protobuf::internal::nameofenum(
    fielddescriptorproto_type_descriptor(), value);
}
inline bool fielddescriptorproto_type_parse(
    const ::std::string& name, fielddescriptorproto_type* value) {
  return ::google::protobuf::internal::parsenamedenum<fielddescriptorproto_type>(
    fielddescriptorproto_type_descriptor(), name, value);
}
enum fielddescriptorproto_label {
  fielddescriptorproto_label_label_optional = 1,
  fielddescriptorproto_label_label_required = 2,
  fielddescriptorproto_label_label_repeated = 3
};
libprotobuf_export bool fielddescriptorproto_label_isvalid(int value);
const fielddescriptorproto_label fielddescriptorproto_label_label_min = fielddescriptorproto_label_label_optional;
const fielddescriptorproto_label fielddescriptorproto_label_label_max = fielddescriptorproto_label_label_repeated;
const int fielddescriptorproto_label_label_arraysize = fielddescriptorproto_label_label_max + 1;

libprotobuf_export const ::google::protobuf::enumdescriptor* fielddescriptorproto_label_descriptor();
inline const ::std::string& fielddescriptorproto_label_name(fielddescriptorproto_label value) {
  return ::google::protobuf::internal::nameofenum(
    fielddescriptorproto_label_descriptor(), value);
}
inline bool fielddescriptorproto_label_parse(
    const ::std::string& name, fielddescriptorproto_label* value) {
  return ::google::protobuf::internal::parsenamedenum<fielddescriptorproto_label>(
    fielddescriptorproto_label_descriptor(), name, value);
}
enum fileoptions_optimizemode {
  fileoptions_optimizemode_speed = 1,
  fileoptions_optimizemode_code_size = 2,
  fileoptions_optimizemode_lite_runtime = 3
};
libprotobuf_export bool fileoptions_optimizemode_isvalid(int value);
const fileoptions_optimizemode fileoptions_optimizemode_optimizemode_min = fileoptions_optimizemode_speed;
const fileoptions_optimizemode fileoptions_optimizemode_optimizemode_max = fileoptions_optimizemode_lite_runtime;
const int fileoptions_optimizemode_optimizemode_arraysize = fileoptions_optimizemode_optimizemode_max + 1;

libprotobuf_export const ::google::protobuf::enumdescriptor* fileoptions_optimizemode_descriptor();
inline const ::std::string& fileoptions_optimizemode_name(fileoptions_optimizemode value) {
  return ::google::protobuf::internal::nameofenum(
    fileoptions_optimizemode_descriptor(), value);
}
inline bool fileoptions_optimizemode_parse(
    const ::std::string& name, fileoptions_optimizemode* value) {
  return ::google::protobuf::internal::parsenamedenum<fileoptions_optimizemode>(
    fileoptions_optimizemode_descriptor(), name, value);
}
enum fieldoptions_ctype {
  fieldoptions_ctype_string = 0,
  fieldoptions_ctype_cord = 1,
  fieldoptions_ctype_string_piece = 2
};
libprotobuf_export bool fieldoptions_ctype_isvalid(int value);
const fieldoptions_ctype fieldoptions_ctype_ctype_min = fieldoptions_ctype_string;
const fieldoptions_ctype fieldoptions_ctype_ctype_max = fieldoptions_ctype_string_piece;
const int fieldoptions_ctype_ctype_arraysize = fieldoptions_ctype_ctype_max + 1;

libprotobuf_export const ::google::protobuf::enumdescriptor* fieldoptions_ctype_descriptor();
inline const ::std::string& fieldoptions_ctype_name(fieldoptions_ctype value) {
  return ::google::protobuf::internal::nameofenum(
    fieldoptions_ctype_descriptor(), value);
}
inline bool fieldoptions_ctype_parse(
    const ::std::string& name, fieldoptions_ctype* value) {
  return ::google::protobuf::internal::parsenamedenum<fieldoptions_ctype>(
    fieldoptions_ctype_descriptor(), name, value);
}
// ===================================================================

class libprotobuf_export filedescriptorset : public ::google::protobuf::message {
 public:
  filedescriptorset();
  virtual ~filedescriptorset();

  filedescriptorset(const filedescriptorset& from);

  inline filedescriptorset& operator=(const filedescriptorset& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const filedescriptorset& default_instance();

  void swap(filedescriptorset* other);

  // implements message ----------------------------------------------

  filedescriptorset* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const filedescriptorset& from);
  void mergefrom(const filedescriptorset& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.filedescriptorproto file = 1;
  inline int file_size() const;
  inline void clear_file();
  static const int kfilefieldnumber = 1;
  inline const ::google::protobuf::filedescriptorproto& file(int index) const;
  inline ::google::protobuf::filedescriptorproto* mutable_file(int index);
  inline ::google::protobuf::filedescriptorproto* add_file();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::filedescriptorproto >&
      file() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::filedescriptorproto >*
      mutable_file();

  // @@protoc_insertion_point(class_scope:google.protobuf.filedescriptorset)
 private:

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::filedescriptorproto > file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static filedescriptorset* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export filedescriptorproto : public ::google::protobuf::message {
 public:
  filedescriptorproto();
  virtual ~filedescriptorproto();

  filedescriptorproto(const filedescriptorproto& from);

  inline filedescriptorproto& operator=(const filedescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const filedescriptorproto& default_instance();

  void swap(filedescriptorproto* other);

  // implements message ----------------------------------------------

  filedescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const filedescriptorproto& from);
  void mergefrom(const filedescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kpackagefieldnumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // repeated string dependency = 3;
  inline int dependency_size() const;
  inline void clear_dependency();
  static const int kdependencyfieldnumber = 3;
  inline const ::std::string& dependency(int index) const;
  inline ::std::string* mutable_dependency(int index);
  inline void set_dependency(int index, const ::std::string& value);
  inline void set_dependency(int index, const char* value);
  inline void set_dependency(int index, const char* value, size_t size);
  inline ::std::string* add_dependency();
  inline void add_dependency(const ::std::string& value);
  inline void add_dependency(const char* value);
  inline void add_dependency(const char* value, size_t size);
  inline const ::google::protobuf::repeatedptrfield< ::std::string>& dependency() const;
  inline ::google::protobuf::repeatedptrfield< ::std::string>* mutable_dependency();

  // repeated int32 public_dependency = 10;
  inline int public_dependency_size() const;
  inline void clear_public_dependency();
  static const int kpublicdependencyfieldnumber = 10;
  inline ::google::protobuf::int32 public_dependency(int index) const;
  inline void set_public_dependency(int index, ::google::protobuf::int32 value);
  inline void add_public_dependency(::google::protobuf::int32 value);
  inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
      public_dependency() const;
  inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
      mutable_public_dependency();

  // repeated int32 weak_dependency = 11;
  inline int weak_dependency_size() const;
  inline void clear_weak_dependency();
  static const int kweakdependencyfieldnumber = 11;
  inline ::google::protobuf::int32 weak_dependency(int index) const;
  inline void set_weak_dependency(int index, ::google::protobuf::int32 value);
  inline void add_weak_dependency(::google::protobuf::int32 value);
  inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
      weak_dependency() const;
  inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
      mutable_weak_dependency();

  // repeated .google.protobuf.descriptorproto message_type = 4;
  inline int message_type_size() const;
  inline void clear_message_type();
  static const int kmessagetypefieldnumber = 4;
  inline const ::google::protobuf::descriptorproto& message_type(int index) const;
  inline ::google::protobuf::descriptorproto* mutable_message_type(int index);
  inline ::google::protobuf::descriptorproto* add_message_type();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >&
      message_type() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >*
      mutable_message_type();

  // repeated .google.protobuf.enumdescriptorproto enum_type = 5;
  inline int enum_type_size() const;
  inline void clear_enum_type();
  static const int kenumtypefieldnumber = 5;
  inline const ::google::protobuf::enumdescriptorproto& enum_type(int index) const;
  inline ::google::protobuf::enumdescriptorproto* mutable_enum_type(int index);
  inline ::google::protobuf::enumdescriptorproto* add_enum_type();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >&
      enum_type() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >*
      mutable_enum_type();

  // repeated .google.protobuf.servicedescriptorproto service = 6;
  inline int service_size() const;
  inline void clear_service();
  static const int kservicefieldnumber = 6;
  inline const ::google::protobuf::servicedescriptorproto& service(int index) const;
  inline ::google::protobuf::servicedescriptorproto* mutable_service(int index);
  inline ::google::protobuf::servicedescriptorproto* add_service();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::servicedescriptorproto >&
      service() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::servicedescriptorproto >*
      mutable_service();

  // repeated .google.protobuf.fielddescriptorproto extension = 7;
  inline int extension_size() const;
  inline void clear_extension();
  static const int kextensionfieldnumber = 7;
  inline const ::google::protobuf::fielddescriptorproto& extension(int index) const;
  inline ::google::protobuf::fielddescriptorproto* mutable_extension(int index);
  inline ::google::protobuf::fielddescriptorproto* add_extension();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
      extension() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
      mutable_extension();

  // optional .google.protobuf.fileoptions options = 8;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 8;
  inline const ::google::protobuf::fileoptions& options() const;
  inline ::google::protobuf::fileoptions* mutable_options();
  inline ::google::protobuf::fileoptions* release_options();
  inline void set_allocated_options(::google::protobuf::fileoptions* options);

  // optional .google.protobuf.sourcecodeinfo source_code_info = 9;
  inline bool has_source_code_info() const;
  inline void clear_source_code_info();
  static const int ksourcecodeinfofieldnumber = 9;
  inline const ::google::protobuf::sourcecodeinfo& source_code_info() const;
  inline ::google::protobuf::sourcecodeinfo* mutable_source_code_info();
  inline ::google::protobuf::sourcecodeinfo* release_source_code_info();
  inline void set_allocated_source_code_info(::google::protobuf::sourcecodeinfo* source_code_info);

  // @@protoc_insertion_point(class_scope:google.protobuf.filedescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_source_code_info();
  inline void clear_has_source_code_info();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::std::string* package_;
  ::google::protobuf::repeatedptrfield< ::std::string> dependency_;
  ::google::protobuf::repeatedfield< ::google::protobuf::int32 > public_dependency_;
  ::google::protobuf::repeatedfield< ::google::protobuf::int32 > weak_dependency_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto > message_type_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto > enum_type_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::servicedescriptorproto > service_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto > extension_;
  ::google::protobuf::fileoptions* options_;
  ::google::protobuf::sourcecodeinfo* source_code_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static filedescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export descriptorproto_extensionrange : public ::google::protobuf::message {
 public:
  descriptorproto_extensionrange();
  virtual ~descriptorproto_extensionrange();

  descriptorproto_extensionrange(const descriptorproto_extensionrange& from);

  inline descriptorproto_extensionrange& operator=(const descriptorproto_extensionrange& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const descriptorproto_extensionrange& default_instance();

  void swap(descriptorproto_extensionrange* other);

  // implements message ----------------------------------------------

  descriptorproto_extensionrange* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const descriptorproto_extensionrange& from);
  void mergefrom(const descriptorproto_extensionrange& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kstartfieldnumber = 1;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kendfieldnumber = 2;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.protobuf.descriptorproto.extensionrange)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static descriptorproto_extensionrange* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export descriptorproto : public ::google::protobuf::message {
 public:
  descriptorproto();
  virtual ~descriptorproto();

  descriptorproto(const descriptorproto& from);

  inline descriptorproto& operator=(const descriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const descriptorproto& default_instance();

  void swap(descriptorproto* other);

  // implements message ----------------------------------------------

  descriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const descriptorproto& from);
  void mergefrom(const descriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef descriptorproto_extensionrange extensionrange;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .google.protobuf.fielddescriptorproto field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kfieldfieldnumber = 2;
  inline const ::google::protobuf::fielddescriptorproto& field(int index) const;
  inline ::google::protobuf::fielddescriptorproto* mutable_field(int index);
  inline ::google::protobuf::fielddescriptorproto* add_field();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
      field() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
      mutable_field();

  // repeated .google.protobuf.fielddescriptorproto extension = 6;
  inline int extension_size() const;
  inline void clear_extension();
  static const int kextensionfieldnumber = 6;
  inline const ::google::protobuf::fielddescriptorproto& extension(int index) const;
  inline ::google::protobuf::fielddescriptorproto* mutable_extension(int index);
  inline ::google::protobuf::fielddescriptorproto* add_extension();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
      extension() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
      mutable_extension();

  // repeated .google.protobuf.descriptorproto nested_type = 3;
  inline int nested_type_size() const;
  inline void clear_nested_type();
  static const int knestedtypefieldnumber = 3;
  inline const ::google::protobuf::descriptorproto& nested_type(int index) const;
  inline ::google::protobuf::descriptorproto* mutable_nested_type(int index);
  inline ::google::protobuf::descriptorproto* add_nested_type();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >&
      nested_type() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >*
      mutable_nested_type();

  // repeated .google.protobuf.enumdescriptorproto enum_type = 4;
  inline int enum_type_size() const;
  inline void clear_enum_type();
  static const int kenumtypefieldnumber = 4;
  inline const ::google::protobuf::enumdescriptorproto& enum_type(int index) const;
  inline ::google::protobuf::enumdescriptorproto* mutable_enum_type(int index);
  inline ::google::protobuf::enumdescriptorproto* add_enum_type();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >&
      enum_type() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >*
      mutable_enum_type();

  // repeated .google.protobuf.descriptorproto.extensionrange extension_range = 5;
  inline int extension_range_size() const;
  inline void clear_extension_range();
  static const int kextensionrangefieldnumber = 5;
  inline const ::google::protobuf::descriptorproto_extensionrange& extension_range(int index) const;
  inline ::google::protobuf::descriptorproto_extensionrange* mutable_extension_range(int index);
  inline ::google::protobuf::descriptorproto_extensionrange* add_extension_range();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto_extensionrange >&
      extension_range() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto_extensionrange >*
      mutable_extension_range();

  // optional .google.protobuf.messageoptions options = 7;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 7;
  inline const ::google::protobuf::messageoptions& options() const;
  inline ::google::protobuf::messageoptions* mutable_options();
  inline ::google::protobuf::messageoptions* release_options();
  inline void set_allocated_options(::google::protobuf::messageoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.descriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto > field_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto > extension_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto > nested_type_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto > enum_type_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto_extensionrange > extension_range_;
  ::google::protobuf::messageoptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static descriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export fielddescriptorproto : public ::google::protobuf::message {
 public:
  fielddescriptorproto();
  virtual ~fielddescriptorproto();

  fielddescriptorproto(const fielddescriptorproto& from);

  inline fielddescriptorproto& operator=(const fielddescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const fielddescriptorproto& default_instance();

  void swap(fielddescriptorproto* other);

  // implements message ----------------------------------------------

  fielddescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const fielddescriptorproto& from);
  void mergefrom(const fielddescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef fielddescriptorproto_type type;
  static const type type_double = fielddescriptorproto_type_type_double;
  static const type type_float = fielddescriptorproto_type_type_float;
  static const type type_int64 = fielddescriptorproto_type_type_int64;
  static const type type_uint64 = fielddescriptorproto_type_type_uint64;
  static const type type_int32 = fielddescriptorproto_type_type_int32;
  static const type type_fixed64 = fielddescriptorproto_type_type_fixed64;
  static const type type_fixed32 = fielddescriptorproto_type_type_fixed32;
  static const type type_bool = fielddescriptorproto_type_type_bool;
  static const type type_string = fielddescriptorproto_type_type_string;
  static const type type_group = fielddescriptorproto_type_type_group;
  static const type type_message = fielddescriptorproto_type_type_message;
  static const type type_bytes = fielddescriptorproto_type_type_bytes;
  static const type type_uint32 = fielddescriptorproto_type_type_uint32;
  static const type type_enum = fielddescriptorproto_type_type_enum;
  static const type type_sfixed32 = fielddescriptorproto_type_type_sfixed32;
  static const type type_sfixed64 = fielddescriptorproto_type_type_sfixed64;
  static const type type_sint32 = fielddescriptorproto_type_type_sint32;
  static const type type_sint64 = fielddescriptorproto_type_type_sint64;
  static inline bool type_isvalid(int value) {
    return fielddescriptorproto_type_isvalid(value);
  }
  static const type type_min =
    fielddescriptorproto_type_type_min;
  static const type type_max =
    fielddescriptorproto_type_type_max;
  static const int type_arraysize =
    fielddescriptorproto_type_type_arraysize;
  static inline const ::google::protobuf::enumdescriptor*
  type_descriptor() {
    return fielddescriptorproto_type_descriptor();
  }
  static inline const ::std::string& type_name(type value) {
    return fielddescriptorproto_type_name(value);
  }
  static inline bool type_parse(const ::std::string& name,
      type* value) {
    return fielddescriptorproto_type_parse(name, value);
  }

  typedef fielddescriptorproto_label label;
  static const label label_optional = fielddescriptorproto_label_label_optional;
  static const label label_required = fielddescriptorproto_label_label_required;
  static const label label_repeated = fielddescriptorproto_label_label_repeated;
  static inline bool label_isvalid(int value) {
    return fielddescriptorproto_label_isvalid(value);
  }
  static const label label_min =
    fielddescriptorproto_label_label_min;
  static const label label_max =
    fielddescriptorproto_label_label_max;
  static const int label_arraysize =
    fielddescriptorproto_label_label_arraysize;
  static inline const ::google::protobuf::enumdescriptor*
  label_descriptor() {
    return fielddescriptorproto_label_descriptor();
  }
  static inline const ::std::string& label_name(label value) {
    return fielddescriptorproto_label_name(value);
  }
  static inline bool label_parse(const ::std::string& name,
      label* value) {
    return fielddescriptorproto_label_parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int knumberfieldnumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional .google.protobuf.fielddescriptorproto.label label = 4;
  inline bool has_label() const;
  inline void clear_label();
  static const int klabelfieldnumber = 4;
  inline ::google::protobuf::fielddescriptorproto_label label() const;
  inline void set_label(::google::protobuf::fielddescriptorproto_label value);

  // optional .google.protobuf.fielddescriptorproto.type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int ktypefieldnumber = 5;
  inline ::google::protobuf::fielddescriptorproto_type type() const;
  inline void set_type(::google::protobuf::fielddescriptorproto_type value);

  // optional string type_name = 6;
  inline bool has_type_name() const;
  inline void clear_type_name();
  static const int ktypenamefieldnumber = 6;
  inline const ::std::string& type_name() const;
  inline void set_type_name(const ::std::string& value);
  inline void set_type_name(const char* value);
  inline void set_type_name(const char* value, size_t size);
  inline ::std::string* mutable_type_name();
  inline ::std::string* release_type_name();
  inline void set_allocated_type_name(::std::string* type_name);

  // optional string extendee = 2;
  inline bool has_extendee() const;
  inline void clear_extendee();
  static const int kextendeefieldnumber = 2;
  inline const ::std::string& extendee() const;
  inline void set_extendee(const ::std::string& value);
  inline void set_extendee(const char* value);
  inline void set_extendee(const char* value, size_t size);
  inline ::std::string* mutable_extendee();
  inline ::std::string* release_extendee();
  inline void set_allocated_extendee(::std::string* extendee);

  // optional string default_value = 7;
  inline bool has_default_value() const;
  inline void clear_default_value();
  static const int kdefaultvaluefieldnumber = 7;
  inline const ::std::string& default_value() const;
  inline void set_default_value(const ::std::string& value);
  inline void set_default_value(const char* value);
  inline void set_default_value(const char* value, size_t size);
  inline ::std::string* mutable_default_value();
  inline ::std::string* release_default_value();
  inline void set_allocated_default_value(::std::string* default_value);

  // optional .google.protobuf.fieldoptions options = 8;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 8;
  inline const ::google::protobuf::fieldoptions& options() const;
  inline ::google::protobuf::fieldoptions* mutable_options();
  inline ::google::protobuf::fieldoptions* release_options();
  inline void set_allocated_options(::google::protobuf::fieldoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.fielddescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_type_name();
  inline void clear_has_type_name();
  inline void set_has_extendee();
  inline void clear_has_extendee();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 number_;
  int label_;
  ::std::string* type_name_;
  ::std::string* extendee_;
  ::std::string* default_value_;
  ::google::protobuf::fieldoptions* options_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static fielddescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export enumdescriptorproto : public ::google::protobuf::message {
 public:
  enumdescriptorproto();
  virtual ~enumdescriptorproto();

  enumdescriptorproto(const enumdescriptorproto& from);

  inline enumdescriptorproto& operator=(const enumdescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const enumdescriptorproto& default_instance();

  void swap(enumdescriptorproto* other);

  // implements message ----------------------------------------------

  enumdescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const enumdescriptorproto& from);
  void mergefrom(const enumdescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .google.protobuf.enumvaluedescriptorproto value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kvaluefieldnumber = 2;
  inline const ::google::protobuf::enumvaluedescriptorproto& value(int index) const;
  inline ::google::protobuf::enumvaluedescriptorproto* mutable_value(int index);
  inline ::google::protobuf::enumvaluedescriptorproto* add_value();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumvaluedescriptorproto >&
      value() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumvaluedescriptorproto >*
      mutable_value();

  // optional .google.protobuf.enumoptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 3;
  inline const ::google::protobuf::enumoptions& options() const;
  inline ::google::protobuf::enumoptions* mutable_options();
  inline ::google::protobuf::enumoptions* release_options();
  inline void set_allocated_options(::google::protobuf::enumoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.enumdescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::enumvaluedescriptorproto > value_;
  ::google::protobuf::enumoptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static enumdescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export enumvaluedescriptorproto : public ::google::protobuf::message {
 public:
  enumvaluedescriptorproto();
  virtual ~enumvaluedescriptorproto();

  enumvaluedescriptorproto(const enumvaluedescriptorproto& from);

  inline enumvaluedescriptorproto& operator=(const enumvaluedescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const enumvaluedescriptorproto& default_instance();

  void swap(enumvaluedescriptorproto* other);

  // implements message ----------------------------------------------

  enumvaluedescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const enumvaluedescriptorproto& from);
  void mergefrom(const enumvaluedescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int knumberfieldnumber = 2;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional .google.protobuf.enumvalueoptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 3;
  inline const ::google::protobuf::enumvalueoptions& options() const;
  inline ::google::protobuf::enumvalueoptions* mutable_options();
  inline ::google::protobuf::enumvalueoptions* release_options();
  inline void set_allocated_options(::google::protobuf::enumvalueoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.enumvaluedescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::enumvalueoptions* options_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static enumvaluedescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export servicedescriptorproto : public ::google::protobuf::message {
 public:
  servicedescriptorproto();
  virtual ~servicedescriptorproto();

  servicedescriptorproto(const servicedescriptorproto& from);

  inline servicedescriptorproto& operator=(const servicedescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const servicedescriptorproto& default_instance();

  void swap(servicedescriptorproto* other);

  // implements message ----------------------------------------------

  servicedescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const servicedescriptorproto& from);
  void mergefrom(const servicedescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .google.protobuf.methoddescriptorproto method = 2;
  inline int method_size() const;
  inline void clear_method();
  static const int kmethodfieldnumber = 2;
  inline const ::google::protobuf::methoddescriptorproto& method(int index) const;
  inline ::google::protobuf::methoddescriptorproto* mutable_method(int index);
  inline ::google::protobuf::methoddescriptorproto* add_method();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::methoddescriptorproto >&
      method() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::methoddescriptorproto >*
      mutable_method();

  // optional .google.protobuf.serviceoptions options = 3;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 3;
  inline const ::google::protobuf::serviceoptions& options() const;
  inline ::google::protobuf::serviceoptions* mutable_options();
  inline ::google::protobuf::serviceoptions* release_options();
  inline void set_allocated_options(::google::protobuf::serviceoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.servicedescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::methoddescriptorproto > method_;
  ::google::protobuf::serviceoptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static servicedescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export methoddescriptorproto : public ::google::protobuf::message {
 public:
  methoddescriptorproto();
  virtual ~methoddescriptorproto();

  methoddescriptorproto(const methoddescriptorproto& from);

  inline methoddescriptorproto& operator=(const methoddescriptorproto& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const methoddescriptorproto& default_instance();

  void swap(methoddescriptorproto* other);

  // implements message ----------------------------------------------

  methoddescriptorproto* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const methoddescriptorproto& from);
  void mergefrom(const methoddescriptorproto& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int knamefieldnumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string input_type = 2;
  inline bool has_input_type() const;
  inline void clear_input_type();
  static const int kinputtypefieldnumber = 2;
  inline const ::std::string& input_type() const;
  inline void set_input_type(const ::std::string& value);
  inline void set_input_type(const char* value);
  inline void set_input_type(const char* value, size_t size);
  inline ::std::string* mutable_input_type();
  inline ::std::string* release_input_type();
  inline void set_allocated_input_type(::std::string* input_type);

  // optional string output_type = 3;
  inline bool has_output_type() const;
  inline void clear_output_type();
  static const int koutputtypefieldnumber = 3;
  inline const ::std::string& output_type() const;
  inline void set_output_type(const ::std::string& value);
  inline void set_output_type(const char* value);
  inline void set_output_type(const char* value, size_t size);
  inline ::std::string* mutable_output_type();
  inline ::std::string* release_output_type();
  inline void set_allocated_output_type(::std::string* output_type);

  // optional .google.protobuf.methodoptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int koptionsfieldnumber = 4;
  inline const ::google::protobuf::methodoptions& options() const;
  inline ::google::protobuf::methodoptions* mutable_options();
  inline ::google::protobuf::methodoptions* release_options();
  inline void set_allocated_options(::google::protobuf::methodoptions* options);

  // @@protoc_insertion_point(class_scope:google.protobuf.methoddescriptorproto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_input_type();
  inline void clear_has_input_type();
  inline void set_has_output_type();
  inline void clear_has_output_type();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_;
  ::std::string* input_type_;
  ::std::string* output_type_;
  ::google::protobuf::methodoptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static methoddescriptorproto* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export fileoptions : public ::google::protobuf::message {
 public:
  fileoptions();
  virtual ~fileoptions();

  fileoptions(const fileoptions& from);

  inline fileoptions& operator=(const fileoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const fileoptions& default_instance();

  void swap(fileoptions* other);

  // implements message ----------------------------------------------

  fileoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const fileoptions& from);
  void mergefrom(const fileoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef fileoptions_optimizemode optimizemode;
  static const optimizemode speed = fileoptions_optimizemode_speed;
  static const optimizemode code_size = fileoptions_optimizemode_code_size;
  static const optimizemode lite_runtime = fileoptions_optimizemode_lite_runtime;
  static inline bool optimizemode_isvalid(int value) {
    return fileoptions_optimizemode_isvalid(value);
  }
  static const optimizemode optimizemode_min =
    fileoptions_optimizemode_optimizemode_min;
  static const optimizemode optimizemode_max =
    fileoptions_optimizemode_optimizemode_max;
  static const int optimizemode_arraysize =
    fileoptions_optimizemode_optimizemode_arraysize;
  static inline const ::google::protobuf::enumdescriptor*
  optimizemode_descriptor() {
    return fileoptions_optimizemode_descriptor();
  }
  static inline const ::std::string& optimizemode_name(optimizemode value) {
    return fileoptions_optimizemode_name(value);
  }
  static inline bool optimizemode_parse(const ::std::string& name,
      optimizemode* value) {
    return fileoptions_optimizemode_parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string java_package = 1;
  inline bool has_java_package() const;
  inline void clear_java_package();
  static const int kjavapackagefieldnumber = 1;
  inline const ::std::string& java_package() const;
  inline void set_java_package(const ::std::string& value);
  inline void set_java_package(const char* value);
  inline void set_java_package(const char* value, size_t size);
  inline ::std::string* mutable_java_package();
  inline ::std::string* release_java_package();
  inline void set_allocated_java_package(::std::string* java_package);

  // optional string java_outer_classname = 8;
  inline bool has_java_outer_classname() const;
  inline void clear_java_outer_classname();
  static const int kjavaouterclassnamefieldnumber = 8;
  inline const ::std::string& java_outer_classname() const;
  inline void set_java_outer_classname(const ::std::string& value);
  inline void set_java_outer_classname(const char* value);
  inline void set_java_outer_classname(const char* value, size_t size);
  inline ::std::string* mutable_java_outer_classname();
  inline ::std::string* release_java_outer_classname();
  inline void set_allocated_java_outer_classname(::std::string* java_outer_classname);

  // optional bool java_multiple_files = 10 [default = false];
  inline bool has_java_multiple_files() const;
  inline void clear_java_multiple_files();
  static const int kjavamultiplefilesfieldnumber = 10;
  inline bool java_multiple_files() const;
  inline void set_java_multiple_files(bool value);

  // optional bool java_generate_equals_and_hash = 20 [default = false];
  inline bool has_java_generate_equals_and_hash() const;
  inline void clear_java_generate_equals_and_hash();
  static const int kjavagenerateequalsandhashfieldnumber = 20;
  inline bool java_generate_equals_and_hash() const;
  inline void set_java_generate_equals_and_hash(bool value);

  // optional .google.protobuf.fileoptions.optimizemode optimize_for = 9 [default = speed];
  inline bool has_optimize_for() const;
  inline void clear_optimize_for();
  static const int koptimizeforfieldnumber = 9;
  inline ::google::protobuf::fileoptions_optimizemode optimize_for() const;
  inline void set_optimize_for(::google::protobuf::fileoptions_optimizemode value);

  // optional string go_package = 11;
  inline bool has_go_package() const;
  inline void clear_go_package();
  static const int kgopackagefieldnumber = 11;
  inline const ::std::string& go_package() const;
  inline void set_go_package(const ::std::string& value);
  inline void set_go_package(const char* value);
  inline void set_go_package(const char* value, size_t size);
  inline ::std::string* mutable_go_package();
  inline ::std::string* release_go_package();
  inline void set_allocated_go_package(::std::string* go_package);

  // optional bool cc_generic_services = 16 [default = false];
  inline bool has_cc_generic_services() const;
  inline void clear_cc_generic_services();
  static const int kccgenericservicesfieldnumber = 16;
  inline bool cc_generic_services() const;
  inline void set_cc_generic_services(bool value);

  // optional bool java_generic_services = 17 [default = false];
  inline bool has_java_generic_services() const;
  inline void clear_java_generic_services();
  static const int kjavagenericservicesfieldnumber = 17;
  inline bool java_generic_services() const;
  inline void set_java_generic_services(bool value);

  // optional bool py_generic_services = 18 [default = false];
  inline bool has_py_generic_services() const;
  inline void clear_py_generic_services();
  static const int kpygenericservicesfieldnumber = 18;
  inline bool py_generic_services() const;
  inline void set_py_generic_services(bool value);

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(fileoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.fileoptions)
 private:
  inline void set_has_java_package();
  inline void clear_has_java_package();
  inline void set_has_java_outer_classname();
  inline void clear_has_java_outer_classname();
  inline void set_has_java_multiple_files();
  inline void clear_has_java_multiple_files();
  inline void set_has_java_generate_equals_and_hash();
  inline void clear_has_java_generate_equals_and_hash();
  inline void set_has_optimize_for();
  inline void clear_has_optimize_for();
  inline void set_has_go_package();
  inline void clear_has_go_package();
  inline void set_has_cc_generic_services();
  inline void clear_has_cc_generic_services();
  inline void set_has_java_generic_services();
  inline void clear_has_java_generic_services();
  inline void set_has_py_generic_services();
  inline void clear_has_py_generic_services();

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* java_package_;
  ::std::string* java_outer_classname_;
  int optimize_for_;
  bool java_multiple_files_;
  bool java_generate_equals_and_hash_;
  bool cc_generic_services_;
  bool java_generic_services_;
  ::std::string* go_package_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;
  bool py_generic_services_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static fileoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export messageoptions : public ::google::protobuf::message {
 public:
  messageoptions();
  virtual ~messageoptions();

  messageoptions(const messageoptions& from);

  inline messageoptions& operator=(const messageoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const messageoptions& default_instance();

  void swap(messageoptions* other);

  // implements message ----------------------------------------------

  messageoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const messageoptions& from);
  void mergefrom(const messageoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool message_set_wire_format = 1 [default = false];
  inline bool has_message_set_wire_format() const;
  inline void clear_message_set_wire_format();
  static const int kmessagesetwireformatfieldnumber = 1;
  inline bool message_set_wire_format() const;
  inline void set_message_set_wire_format(bool value);

  // optional bool no_standard_descriptor_accessor = 2 [default = false];
  inline bool has_no_standard_descriptor_accessor() const;
  inline void clear_no_standard_descriptor_accessor();
  static const int knostandarddescriptoraccessorfieldnumber = 2;
  inline bool no_standard_descriptor_accessor() const;
  inline void set_no_standard_descriptor_accessor(bool value);

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(messageoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.messageoptions)
 private:
  inline void set_has_message_set_wire_format();
  inline void clear_has_message_set_wire_format();
  inline void set_has_no_standard_descriptor_accessor();
  inline void clear_has_no_standard_descriptor_accessor();

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;
  bool message_set_wire_format_;
  bool no_standard_descriptor_accessor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static messageoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export fieldoptions : public ::google::protobuf::message {
 public:
  fieldoptions();
  virtual ~fieldoptions();

  fieldoptions(const fieldoptions& from);

  inline fieldoptions& operator=(const fieldoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const fieldoptions& default_instance();

  void swap(fieldoptions* other);

  // implements message ----------------------------------------------

  fieldoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const fieldoptions& from);
  void mergefrom(const fieldoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef fieldoptions_ctype ctype;
  static const ctype string = fieldoptions_ctype_string;
  static const ctype cord = fieldoptions_ctype_cord;
  static const ctype string_piece = fieldoptions_ctype_string_piece;
  static inline bool ctype_isvalid(int value) {
    return fieldoptions_ctype_isvalid(value);
  }
  static const ctype ctype_min =
    fieldoptions_ctype_ctype_min;
  static const ctype ctype_max =
    fieldoptions_ctype_ctype_max;
  static const int ctype_arraysize =
    fieldoptions_ctype_ctype_arraysize;
  static inline const ::google::protobuf::enumdescriptor*
  ctype_descriptor() {
    return fieldoptions_ctype_descriptor();
  }
  static inline const ::std::string& ctype_name(ctype value) {
    return fieldoptions_ctype_name(value);
  }
  static inline bool ctype_parse(const ::std::string& name,
      ctype* value) {
    return fieldoptions_ctype_parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .google.protobuf.fieldoptions.ctype ctype = 1 [default = string];
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kctypefieldnumber = 1;
  inline ::google::protobuf::fieldoptions_ctype ctype() const;
  inline void set_ctype(::google::protobuf::fieldoptions_ctype value);

  // optional bool packed = 2;
  inline bool has_packed() const;
  inline void clear_packed();
  static const int kpackedfieldnumber = 2;
  inline bool packed() const;
  inline void set_packed(bool value);

  // optional bool lazy = 5 [default = false];
  inline bool has_lazy() const;
  inline void clear_lazy();
  static const int klazyfieldnumber = 5;
  inline bool lazy() const;
  inline void set_lazy(bool value);

  // optional bool deprecated = 3 [default = false];
  inline bool has_deprecated() const;
  inline void clear_deprecated();
  static const int kdeprecatedfieldnumber = 3;
  inline bool deprecated() const;
  inline void set_deprecated(bool value);

  // optional string experimental_map_key = 9;
  inline bool has_experimental_map_key() const;
  inline void clear_experimental_map_key();
  static const int kexperimentalmapkeyfieldnumber = 9;
  inline const ::std::string& experimental_map_key() const;
  inline void set_experimental_map_key(const ::std::string& value);
  inline void set_experimental_map_key(const char* value);
  inline void set_experimental_map_key(const char* value, size_t size);
  inline ::std::string* mutable_experimental_map_key();
  inline ::std::string* release_experimental_map_key();
  inline void set_allocated_experimental_map_key(::std::string* experimental_map_key);

  // optional bool weak = 10 [default = false];
  inline bool has_weak() const;
  inline void clear_weak();
  static const int kweakfieldnumber = 10;
  inline bool weak() const;
  inline void set_weak(bool value);

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(fieldoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.fieldoptions)
 private:
  inline void set_has_ctype();
  inline void clear_has_ctype();
  inline void set_has_packed();
  inline void clear_has_packed();
  inline void set_has_lazy();
  inline void clear_has_lazy();
  inline void set_has_deprecated();
  inline void clear_has_deprecated();
  inline void set_has_experimental_map_key();
  inline void clear_has_experimental_map_key();
  inline void set_has_weak();
  inline void clear_has_weak();

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  int ctype_;
  bool packed_;
  bool lazy_;
  bool deprecated_;
  bool weak_;
  ::std::string* experimental_map_key_;
  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static fieldoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export enumoptions : public ::google::protobuf::message {
 public:
  enumoptions();
  virtual ~enumoptions();

  enumoptions(const enumoptions& from);

  inline enumoptions& operator=(const enumoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const enumoptions& default_instance();

  void swap(enumoptions* other);

  // implements message ----------------------------------------------

  enumoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const enumoptions& from);
  void mergefrom(const enumoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool allow_alias = 2 [default = true];
  inline bool has_allow_alias() const;
  inline void clear_allow_alias();
  static const int kallowaliasfieldnumber = 2;
  inline bool allow_alias() const;
  inline void set_allow_alias(bool value);

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(enumoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.enumoptions)
 private:
  inline void set_has_allow_alias();
  inline void clear_has_allow_alias();

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;
  bool allow_alias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static enumoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export enumvalueoptions : public ::google::protobuf::message {
 public:
  enumvalueoptions();
  virtual ~enumvalueoptions();

  enumvalueoptions(const enumvalueoptions& from);

  inline enumvalueoptions& operator=(const enumvalueoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const enumvalueoptions& default_instance();

  void swap(enumvalueoptions* other);

  // implements message ----------------------------------------------

  enumvalueoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const enumvalueoptions& from);
  void mergefrom(const enumvalueoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(enumvalueoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.enumvalueoptions)
 private:

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static enumvalueoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export serviceoptions : public ::google::protobuf::message {
 public:
  serviceoptions();
  virtual ~serviceoptions();

  serviceoptions(const serviceoptions& from);

  inline serviceoptions& operator=(const serviceoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const serviceoptions& default_instance();

  void swap(serviceoptions* other);

  // implements message ----------------------------------------------

  serviceoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const serviceoptions& from);
  void mergefrom(const serviceoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(serviceoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.serviceoptions)
 private:

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static serviceoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export methodoptions : public ::google::protobuf::message {
 public:
  methodoptions();
  virtual ~methodoptions();

  methodoptions(const methodoptions& from);

  inline methodoptions& operator=(const methodoptions& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const methodoptions& default_instance();

  void swap(methodoptions* other);

  // implements message ----------------------------------------------

  methodoptions* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const methodoptions& from);
  void mergefrom(const methodoptions& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
  inline int uninterpreted_option_size() const;
  inline void clear_uninterpreted_option();
  static const int kuninterpretedoptionfieldnumber = 999;
  inline const ::google::protobuf::uninterpretedoption& uninterpreted_option(int index) const;
  inline ::google::protobuf::uninterpretedoption* mutable_uninterpreted_option(int index);
  inline ::google::protobuf::uninterpretedoption* add_uninterpreted_option();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
      uninterpreted_option() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
      mutable_uninterpreted_option();

  google_protobuf_extension_accessors(methodoptions)
  // @@protoc_insertion_point(class_scope:google.protobuf.methodoptions)
 private:

  ::google::protobuf::internal::extensionset _extensions_;

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption > uninterpreted_option_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static methodoptions* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export uninterpretedoption_namepart : public ::google::protobuf::message {
 public:
  uninterpretedoption_namepart();
  virtual ~uninterpretedoption_namepart();

  uninterpretedoption_namepart(const uninterpretedoption_namepart& from);

  inline uninterpretedoption_namepart& operator=(const uninterpretedoption_namepart& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const uninterpretedoption_namepart& default_instance();

  void swap(uninterpretedoption_namepart* other);

  // implements message ----------------------------------------------

  uninterpretedoption_namepart* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const uninterpretedoption_namepart& from);
  void mergefrom(const uninterpretedoption_namepart& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_part = 1;
  inline bool has_name_part() const;
  inline void clear_name_part();
  static const int knamepartfieldnumber = 1;
  inline const ::std::string& name_part() const;
  inline void set_name_part(const ::std::string& value);
  inline void set_name_part(const char* value);
  inline void set_name_part(const char* value, size_t size);
  inline ::std::string* mutable_name_part();
  inline ::std::string* release_name_part();
  inline void set_allocated_name_part(::std::string* name_part);

  // required bool is_extension = 2;
  inline bool has_is_extension() const;
  inline void clear_is_extension();
  static const int kisextensionfieldnumber = 2;
  inline bool is_extension() const;
  inline void set_is_extension(bool value);

  // @@protoc_insertion_point(class_scope:google.protobuf.uninterpretedoption.namepart)
 private:
  inline void set_has_name_part();
  inline void clear_has_name_part();
  inline void set_has_is_extension();
  inline void clear_has_is_extension();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::std::string* name_part_;
  bool is_extension_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static uninterpretedoption_namepart* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export uninterpretedoption : public ::google::protobuf::message {
 public:
  uninterpretedoption();
  virtual ~uninterpretedoption();

  uninterpretedoption(const uninterpretedoption& from);

  inline uninterpretedoption& operator=(const uninterpretedoption& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const uninterpretedoption& default_instance();

  void swap(uninterpretedoption* other);

  // implements message ----------------------------------------------

  uninterpretedoption* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const uninterpretedoption& from);
  void mergefrom(const uninterpretedoption& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef uninterpretedoption_namepart namepart;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.uninterpretedoption.namepart name = 2;
  inline int name_size() const;
  inline void clear_name();
  static const int knamefieldnumber = 2;
  inline const ::google::protobuf::uninterpretedoption_namepart& name(int index) const;
  inline ::google::protobuf::uninterpretedoption_namepart* mutable_name(int index);
  inline ::google::protobuf::uninterpretedoption_namepart* add_name();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption_namepart >&
      name() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption_namepart >*
      mutable_name();

  // optional string identifier_value = 3;
  inline bool has_identifier_value() const;
  inline void clear_identifier_value();
  static const int kidentifiervaluefieldnumber = 3;
  inline const ::std::string& identifier_value() const;
  inline void set_identifier_value(const ::std::string& value);
  inline void set_identifier_value(const char* value);
  inline void set_identifier_value(const char* value, size_t size);
  inline ::std::string* mutable_identifier_value();
  inline ::std::string* release_identifier_value();
  inline void set_allocated_identifier_value(::std::string* identifier_value);

  // optional uint64 positive_int_value = 4;
  inline bool has_positive_int_value() const;
  inline void clear_positive_int_value();
  static const int kpositiveintvaluefieldnumber = 4;
  inline ::google::protobuf::uint64 positive_int_value() const;
  inline void set_positive_int_value(::google::protobuf::uint64 value);

  // optional int64 negative_int_value = 5;
  inline bool has_negative_int_value() const;
  inline void clear_negative_int_value();
  static const int knegativeintvaluefieldnumber = 5;
  inline ::google::protobuf::int64 negative_int_value() const;
  inline void set_negative_int_value(::google::protobuf::int64 value);

  // optional double double_value = 6;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kdoublevaluefieldnumber = 6;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional bytes string_value = 7;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kstringvaluefieldnumber = 7;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const void* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional string aggregate_value = 8;
  inline bool has_aggregate_value() const;
  inline void clear_aggregate_value();
  static const int kaggregatevaluefieldnumber = 8;
  inline const ::std::string& aggregate_value() const;
  inline void set_aggregate_value(const ::std::string& value);
  inline void set_aggregate_value(const char* value);
  inline void set_aggregate_value(const char* value, size_t size);
  inline ::std::string* mutable_aggregate_value();
  inline ::std::string* release_aggregate_value();
  inline void set_allocated_aggregate_value(::std::string* aggregate_value);

  // @@protoc_insertion_point(class_scope:google.protobuf.uninterpretedoption)
 private:
  inline void set_has_identifier_value();
  inline void clear_has_identifier_value();
  inline void set_has_positive_int_value();
  inline void clear_has_positive_int_value();
  inline void set_has_negative_int_value();
  inline void clear_has_negative_int_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_aggregate_value();
  inline void clear_has_aggregate_value();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption_namepart > name_;
  ::std::string* identifier_value_;
  ::google::protobuf::uint64 positive_int_value_;
  ::google::protobuf::int64 negative_int_value_;
  double double_value_;
  ::std::string* string_value_;
  ::std::string* aggregate_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static uninterpretedoption* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export sourcecodeinfo_location : public ::google::protobuf::message {
 public:
  sourcecodeinfo_location();
  virtual ~sourcecodeinfo_location();

  sourcecodeinfo_location(const sourcecodeinfo_location& from);

  inline sourcecodeinfo_location& operator=(const sourcecodeinfo_location& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const sourcecodeinfo_location& default_instance();

  void swap(sourcecodeinfo_location* other);

  // implements message ----------------------------------------------

  sourcecodeinfo_location* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const sourcecodeinfo_location& from);
  void mergefrom(const sourcecodeinfo_location& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 path = 1 [packed = true];
  inline int path_size() const;
  inline void clear_path();
  static const int kpathfieldnumber = 1;
  inline ::google::protobuf::int32 path(int index) const;
  inline void set_path(int index, ::google::protobuf::int32 value);
  inline void add_path(::google::protobuf::int32 value);
  inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
      path() const;
  inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
      mutable_path();

  // repeated int32 span = 2 [packed = true];
  inline int span_size() const;
  inline void clear_span();
  static const int kspanfieldnumber = 2;
  inline ::google::protobuf::int32 span(int index) const;
  inline void set_span(int index, ::google::protobuf::int32 value);
  inline void add_span(::google::protobuf::int32 value);
  inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
      span() const;
  inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
      mutable_span();

  // optional string leading_comments = 3;
  inline bool has_leading_comments() const;
  inline void clear_leading_comments();
  static const int kleadingcommentsfieldnumber = 3;
  inline const ::std::string& leading_comments() const;
  inline void set_leading_comments(const ::std::string& value);
  inline void set_leading_comments(const char* value);
  inline void set_leading_comments(const char* value, size_t size);
  inline ::std::string* mutable_leading_comments();
  inline ::std::string* release_leading_comments();
  inline void set_allocated_leading_comments(::std::string* leading_comments);

  // optional string trailing_comments = 4;
  inline bool has_trailing_comments() const;
  inline void clear_trailing_comments();
  static const int ktrailingcommentsfieldnumber = 4;
  inline const ::std::string& trailing_comments() const;
  inline void set_trailing_comments(const ::std::string& value);
  inline void set_trailing_comments(const char* value);
  inline void set_trailing_comments(const char* value, size_t size);
  inline ::std::string* mutable_trailing_comments();
  inline ::std::string* release_trailing_comments();
  inline void set_allocated_trailing_comments(::std::string* trailing_comments);

  // @@protoc_insertion_point(class_scope:google.protobuf.sourcecodeinfo.location)
 private:
  inline void set_has_leading_comments();
  inline void clear_has_leading_comments();
  inline void set_has_trailing_comments();
  inline void clear_has_trailing_comments();

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedfield< ::google::protobuf::int32 > path_;
  mutable int _path_cached_byte_size_;
  ::google::protobuf::repeatedfield< ::google::protobuf::int32 > span_;
  mutable int _span_cached_byte_size_;
  ::std::string* leading_comments_;
  ::std::string* trailing_comments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static sourcecodeinfo_location* default_instance_;
};
// -------------------------------------------------------------------

class libprotobuf_export sourcecodeinfo : public ::google::protobuf::message {
 public:
  sourcecodeinfo();
  virtual ~sourcecodeinfo();

  sourcecodeinfo(const sourcecodeinfo& from);

  inline sourcecodeinfo& operator=(const sourcecodeinfo& from) {
    copyfrom(from);
    return *this;
  }

  inline const ::google::protobuf::unknownfieldset& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::unknownfieldset* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::descriptor* descriptor();
  static const sourcecodeinfo& default_instance();

  void swap(sourcecodeinfo* other);

  // implements message ----------------------------------------------

  sourcecodeinfo* new() const;
  void copyfrom(const ::google::protobuf::message& from);
  void mergefrom(const ::google::protobuf::message& from);
  void copyfrom(const sourcecodeinfo& from);
  void mergefrom(const sourcecodeinfo& from);
  void clear();
  bool isinitialized() const;

  int bytesize() const;
  bool mergepartialfromcodedstream(
      ::google::protobuf::io::codedinputstream* input);
  void serializewithcachedsizes(
      ::google::protobuf::io::codedoutputstream* output) const;
  ::google::protobuf::uint8* serializewithcachedsizestoarray(::google::protobuf::uint8* output) const;
  int getcachedsize() const { return _cached_size_; }
  private:
  void sharedctor();
  void shareddtor();
  void setcachedsize(int size) const;
  public:

  ::google::protobuf::metadata getmetadata() const;

  // nested types ----------------------------------------------------

  typedef sourcecodeinfo_location location;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.sourcecodeinfo.location location = 1;
  inline int location_size() const;
  inline void clear_location();
  static const int klocationfieldnumber = 1;
  inline const ::google::protobuf::sourcecodeinfo_location& location(int index) const;
  inline ::google::protobuf::sourcecodeinfo_location* mutable_location(int index);
  inline ::google::protobuf::sourcecodeinfo_location* add_location();
  inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::sourcecodeinfo_location >&
      location() const;
  inline ::google::protobuf::repeatedptrfield< ::google::protobuf::sourcecodeinfo_location >*
      mutable_location();

  // @@protoc_insertion_point(class_scope:google.protobuf.sourcecodeinfo)
 private:

  ::google::protobuf::unknownfieldset _unknown_fields_;

  ::google::protobuf::repeatedptrfield< ::google::protobuf::sourcecodeinfo_location > location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void libprotobuf_export protobuf_adddesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_assigndesc_google_2fprotobuf_2fdescriptor_2eproto();
  friend void protobuf_shutdownfile_google_2fprotobuf_2fdescriptor_2eproto();

  void initasdefaultinstance();
  static sourcecodeinfo* default_instance_;
};
// ===================================================================


// ===================================================================

// filedescriptorset

// repeated .google.protobuf.filedescriptorproto file = 1;
inline int filedescriptorset::file_size() const {
  return file_.size();
}
inline void filedescriptorset::clear_file() {
  file_.clear();
}
inline const ::google::protobuf::filedescriptorproto& filedescriptorset::file(int index) const {
  return file_.get(index);
}
inline ::google::protobuf::filedescriptorproto* filedescriptorset::mutable_file(int index) {
  return file_.mutable(index);
}
inline ::google::protobuf::filedescriptorproto* filedescriptorset::add_file() {
  return file_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::filedescriptorproto >&
filedescriptorset::file() const {
  return file_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::filedescriptorproto >*
filedescriptorset::mutable_file() {
  return &file_;
}

// -------------------------------------------------------------------

// filedescriptorproto

// optional string name = 1;
inline bool filedescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void filedescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void filedescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void filedescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& filedescriptorproto::name() const {
  return *name_;
}
inline void filedescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void filedescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void filedescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* filedescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* filedescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void filedescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string package = 2;
inline bool filedescriptorproto::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void filedescriptorproto::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void filedescriptorproto::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void filedescriptorproto::clear_package() {
  if (package_ != &::google::protobuf::internal::kemptystring) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& filedescriptorproto::package() const {
  return *package_;
}
inline void filedescriptorproto::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kemptystring) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void filedescriptorproto::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kemptystring) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void filedescriptorproto::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kemptystring) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* filedescriptorproto::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kemptystring) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* filedescriptorproto::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void filedescriptorproto::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kemptystring) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// repeated string dependency = 3;
inline int filedescriptorproto::dependency_size() const {
  return dependency_.size();
}
inline void filedescriptorproto::clear_dependency() {
  dependency_.clear();
}
inline const ::std::string& filedescriptorproto::dependency(int index) const {
  return dependency_.get(index);
}
inline ::std::string* filedescriptorproto::mutable_dependency(int index) {
  return dependency_.mutable(index);
}
inline void filedescriptorproto::set_dependency(int index, const ::std::string& value) {
  dependency_.mutable(index)->assign(value);
}
inline void filedescriptorproto::set_dependency(int index, const char* value) {
  dependency_.mutable(index)->assign(value);
}
inline void filedescriptorproto::set_dependency(int index, const char* value, size_t size) {
  dependency_.mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* filedescriptorproto::add_dependency() {
  return dependency_.add();
}
inline void filedescriptorproto::add_dependency(const ::std::string& value) {
  dependency_.add()->assign(value);
}
inline void filedescriptorproto::add_dependency(const char* value) {
  dependency_.add()->assign(value);
}
inline void filedescriptorproto::add_dependency(const char* value, size_t size) {
  dependency_.add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::repeatedptrfield< ::std::string>&
filedescriptorproto::dependency() const {
  return dependency_;
}
inline ::google::protobuf::repeatedptrfield< ::std::string>*
filedescriptorproto::mutable_dependency() {
  return &dependency_;
}

// repeated int32 public_dependency = 10;
inline int filedescriptorproto::public_dependency_size() const {
  return public_dependency_.size();
}
inline void filedescriptorproto::clear_public_dependency() {
  public_dependency_.clear();
}
inline ::google::protobuf::int32 filedescriptorproto::public_dependency(int index) const {
  return public_dependency_.get(index);
}
inline void filedescriptorproto::set_public_dependency(int index, ::google::protobuf::int32 value) {
  public_dependency_.set(index, value);
}
inline void filedescriptorproto::add_public_dependency(::google::protobuf::int32 value) {
  public_dependency_.add(value);
}
inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
filedescriptorproto::public_dependency() const {
  return public_dependency_;
}
inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
filedescriptorproto::mutable_public_dependency() {
  return &public_dependency_;
}

// repeated int32 weak_dependency = 11;
inline int filedescriptorproto::weak_dependency_size() const {
  return weak_dependency_.size();
}
inline void filedescriptorproto::clear_weak_dependency() {
  weak_dependency_.clear();
}
inline ::google::protobuf::int32 filedescriptorproto::weak_dependency(int index) const {
  return weak_dependency_.get(index);
}
inline void filedescriptorproto::set_weak_dependency(int index, ::google::protobuf::int32 value) {
  weak_dependency_.set(index, value);
}
inline void filedescriptorproto::add_weak_dependency(::google::protobuf::int32 value) {
  weak_dependency_.add(value);
}
inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
filedescriptorproto::weak_dependency() const {
  return weak_dependency_;
}
inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
filedescriptorproto::mutable_weak_dependency() {
  return &weak_dependency_;
}

// repeated .google.protobuf.descriptorproto message_type = 4;
inline int filedescriptorproto::message_type_size() const {
  return message_type_.size();
}
inline void filedescriptorproto::clear_message_type() {
  message_type_.clear();
}
inline const ::google::protobuf::descriptorproto& filedescriptorproto::message_type(int index) const {
  return message_type_.get(index);
}
inline ::google::protobuf::descriptorproto* filedescriptorproto::mutable_message_type(int index) {
  return message_type_.mutable(index);
}
inline ::google::protobuf::descriptorproto* filedescriptorproto::add_message_type() {
  return message_type_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >&
filedescriptorproto::message_type() const {
  return message_type_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >*
filedescriptorproto::mutable_message_type() {
  return &message_type_;
}

// repeated .google.protobuf.enumdescriptorproto enum_type = 5;
inline int filedescriptorproto::enum_type_size() const {
  return enum_type_.size();
}
inline void filedescriptorproto::clear_enum_type() {
  enum_type_.clear();
}
inline const ::google::protobuf::enumdescriptorproto& filedescriptorproto::enum_type(int index) const {
  return enum_type_.get(index);
}
inline ::google::protobuf::enumdescriptorproto* filedescriptorproto::mutable_enum_type(int index) {
  return enum_type_.mutable(index);
}
inline ::google::protobuf::enumdescriptorproto* filedescriptorproto::add_enum_type() {
  return enum_type_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >&
filedescriptorproto::enum_type() const {
  return enum_type_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >*
filedescriptorproto::mutable_enum_type() {
  return &enum_type_;
}

// repeated .google.protobuf.servicedescriptorproto service = 6;
inline int filedescriptorproto::service_size() const {
  return service_.size();
}
inline void filedescriptorproto::clear_service() {
  service_.clear();
}
inline const ::google::protobuf::servicedescriptorproto& filedescriptorproto::service(int index) const {
  return service_.get(index);
}
inline ::google::protobuf::servicedescriptorproto* filedescriptorproto::mutable_service(int index) {
  return service_.mutable(index);
}
inline ::google::protobuf::servicedescriptorproto* filedescriptorproto::add_service() {
  return service_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::servicedescriptorproto >&
filedescriptorproto::service() const {
  return service_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::servicedescriptorproto >*
filedescriptorproto::mutable_service() {
  return &service_;
}

// repeated .google.protobuf.fielddescriptorproto extension = 7;
inline int filedescriptorproto::extension_size() const {
  return extension_.size();
}
inline void filedescriptorproto::clear_extension() {
  extension_.clear();
}
inline const ::google::protobuf::fielddescriptorproto& filedescriptorproto::extension(int index) const {
  return extension_.get(index);
}
inline ::google::protobuf::fielddescriptorproto* filedescriptorproto::mutable_extension(int index) {
  return extension_.mutable(index);
}
inline ::google::protobuf::fielddescriptorproto* filedescriptorproto::add_extension() {
  return extension_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
filedescriptorproto::extension() const {
  return extension_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
filedescriptorproto::mutable_extension() {
  return &extension_;
}

// optional .google.protobuf.fileoptions options = 8;
inline bool filedescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void filedescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000200u;
}
inline void filedescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void filedescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::fileoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::fileoptions& filedescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::fileoptions* filedescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::fileoptions;
  return options_;
}
inline ::google::protobuf::fileoptions* filedescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::fileoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void filedescriptorproto::set_allocated_options(::google::protobuf::fileoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional .google.protobuf.sourcecodeinfo source_code_info = 9;
inline bool filedescriptorproto::has_source_code_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void filedescriptorproto::set_has_source_code_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void filedescriptorproto::clear_has_source_code_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void filedescriptorproto::clear_source_code_info() {
  if (source_code_info_ != null) source_code_info_->::google::protobuf::sourcecodeinfo::clear();
  clear_has_source_code_info();
}
inline const ::google::protobuf::sourcecodeinfo& filedescriptorproto::source_code_info() const {
  return source_code_info_ != null ? *source_code_info_ : *default_instance_->source_code_info_;
}
inline ::google::protobuf::sourcecodeinfo* filedescriptorproto::mutable_source_code_info() {
  set_has_source_code_info();
  if (source_code_info_ == null) source_code_info_ = new ::google::protobuf::sourcecodeinfo;
  return source_code_info_;
}
inline ::google::protobuf::sourcecodeinfo* filedescriptorproto::release_source_code_info() {
  clear_has_source_code_info();
  ::google::protobuf::sourcecodeinfo* temp = source_code_info_;
  source_code_info_ = null;
  return temp;
}
inline void filedescriptorproto::set_allocated_source_code_info(::google::protobuf::sourcecodeinfo* source_code_info) {
  delete source_code_info_;
  source_code_info_ = source_code_info;
  if (source_code_info) {
    set_has_source_code_info();
  } else {
    clear_has_source_code_info();
  }
}

// -------------------------------------------------------------------

// descriptorproto_extensionrange

// optional int32 start = 1;
inline bool descriptorproto_extensionrange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void descriptorproto_extensionrange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void descriptorproto_extensionrange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void descriptorproto_extensionrange::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 descriptorproto_extensionrange::start() const {
  return start_;
}
inline void descriptorproto_extensionrange::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 end = 2;
inline bool descriptorproto_extensionrange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void descriptorproto_extensionrange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void descriptorproto_extensionrange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void descriptorproto_extensionrange::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 descriptorproto_extensionrange::end() const {
  return end_;
}
inline void descriptorproto_extensionrange::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// descriptorproto

// optional string name = 1;
inline bool descriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void descriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void descriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void descriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& descriptorproto::name() const {
  return *name_;
}
inline void descriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void descriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void descriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* descriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* descriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void descriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// repeated .google.protobuf.fielddescriptorproto field = 2;
inline int descriptorproto::field_size() const {
  return field_.size();
}
inline void descriptorproto::clear_field() {
  field_.clear();
}
inline const ::google::protobuf::fielddescriptorproto& descriptorproto::field(int index) const {
  return field_.get(index);
}
inline ::google::protobuf::fielddescriptorproto* descriptorproto::mutable_field(int index) {
  return field_.mutable(index);
}
inline ::google::protobuf::fielddescriptorproto* descriptorproto::add_field() {
  return field_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
descriptorproto::field() const {
  return field_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
descriptorproto::mutable_field() {
  return &field_;
}

// repeated .google.protobuf.fielddescriptorproto extension = 6;
inline int descriptorproto::extension_size() const {
  return extension_.size();
}
inline void descriptorproto::clear_extension() {
  extension_.clear();
}
inline const ::google::protobuf::fielddescriptorproto& descriptorproto::extension(int index) const {
  return extension_.get(index);
}
inline ::google::protobuf::fielddescriptorproto* descriptorproto::mutable_extension(int index) {
  return extension_.mutable(index);
}
inline ::google::protobuf::fielddescriptorproto* descriptorproto::add_extension() {
  return extension_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >&
descriptorproto::extension() const {
  return extension_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::fielddescriptorproto >*
descriptorproto::mutable_extension() {
  return &extension_;
}

// repeated .google.protobuf.descriptorproto nested_type = 3;
inline int descriptorproto::nested_type_size() const {
  return nested_type_.size();
}
inline void descriptorproto::clear_nested_type() {
  nested_type_.clear();
}
inline const ::google::protobuf::descriptorproto& descriptorproto::nested_type(int index) const {
  return nested_type_.get(index);
}
inline ::google::protobuf::descriptorproto* descriptorproto::mutable_nested_type(int index) {
  return nested_type_.mutable(index);
}
inline ::google::protobuf::descriptorproto* descriptorproto::add_nested_type() {
  return nested_type_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >&
descriptorproto::nested_type() const {
  return nested_type_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto >*
descriptorproto::mutable_nested_type() {
  return &nested_type_;
}

// repeated .google.protobuf.enumdescriptorproto enum_type = 4;
inline int descriptorproto::enum_type_size() const {
  return enum_type_.size();
}
inline void descriptorproto::clear_enum_type() {
  enum_type_.clear();
}
inline const ::google::protobuf::enumdescriptorproto& descriptorproto::enum_type(int index) const {
  return enum_type_.get(index);
}
inline ::google::protobuf::enumdescriptorproto* descriptorproto::mutable_enum_type(int index) {
  return enum_type_.mutable(index);
}
inline ::google::protobuf::enumdescriptorproto* descriptorproto::add_enum_type() {
  return enum_type_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >&
descriptorproto::enum_type() const {
  return enum_type_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumdescriptorproto >*
descriptorproto::mutable_enum_type() {
  return &enum_type_;
}

// repeated .google.protobuf.descriptorproto.extensionrange extension_range = 5;
inline int descriptorproto::extension_range_size() const {
  return extension_range_.size();
}
inline void descriptorproto::clear_extension_range() {
  extension_range_.clear();
}
inline const ::google::protobuf::descriptorproto_extensionrange& descriptorproto::extension_range(int index) const {
  return extension_range_.get(index);
}
inline ::google::protobuf::descriptorproto_extensionrange* descriptorproto::mutable_extension_range(int index) {
  return extension_range_.mutable(index);
}
inline ::google::protobuf::descriptorproto_extensionrange* descriptorproto::add_extension_range() {
  return extension_range_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto_extensionrange >&
descriptorproto::extension_range() const {
  return extension_range_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::descriptorproto_extensionrange >*
descriptorproto::mutable_extension_range() {
  return &extension_range_;
}

// optional .google.protobuf.messageoptions options = 7;
inline bool descriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void descriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000040u;
}
inline void descriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void descriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::messageoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::messageoptions& descriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::messageoptions* descriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::messageoptions;
  return options_;
}
inline ::google::protobuf::messageoptions* descriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::messageoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void descriptorproto::set_allocated_options(::google::protobuf::messageoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// fielddescriptorproto

// optional string name = 1;
inline bool fielddescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fielddescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fielddescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fielddescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& fielddescriptorproto::name() const {
  return *name_;
}
inline void fielddescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void fielddescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void fielddescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fielddescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* fielddescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fielddescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional int32 number = 3;
inline bool fielddescriptorproto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fielddescriptorproto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fielddescriptorproto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fielddescriptorproto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 fielddescriptorproto::number() const {
  return number_;
}
inline void fielddescriptorproto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional .google.protobuf.fielddescriptorproto.label label = 4;
inline bool fielddescriptorproto::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fielddescriptorproto::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fielddescriptorproto::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fielddescriptorproto::clear_label() {
  label_ = 1;
  clear_has_label();
}
inline ::google::protobuf::fielddescriptorproto_label fielddescriptorproto::label() const {
  return static_cast< ::google::protobuf::fielddescriptorproto_label >(label_);
}
inline void fielddescriptorproto::set_label(::google::protobuf::fielddescriptorproto_label value) {
  assert(::google::protobuf::fielddescriptorproto_label_isvalid(value));
  set_has_label();
  label_ = value;
}

// optional .google.protobuf.fielddescriptorproto.type type = 5;
inline bool fielddescriptorproto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fielddescriptorproto::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fielddescriptorproto::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fielddescriptorproto::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::google::protobuf::fielddescriptorproto_type fielddescriptorproto::type() const {
  return static_cast< ::google::protobuf::fielddescriptorproto_type >(type_);
}
inline void fielddescriptorproto::set_type(::google::protobuf::fielddescriptorproto_type value) {
  assert(::google::protobuf::fielddescriptorproto_type_isvalid(value));
  set_has_type();
  type_ = value;
}

// optional string type_name = 6;
inline bool fielddescriptorproto::has_type_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fielddescriptorproto::set_has_type_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fielddescriptorproto::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fielddescriptorproto::clear_type_name() {
  if (type_name_ != &::google::protobuf::internal::kemptystring) {
    type_name_->clear();
  }
  clear_has_type_name();
}
inline const ::std::string& fielddescriptorproto::type_name() const {
  return *type_name_;
}
inline void fielddescriptorproto::set_type_name(const ::std::string& value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kemptystring) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
}
inline void fielddescriptorproto::set_type_name(const char* value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kemptystring) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
}
inline void fielddescriptorproto::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kemptystring) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fielddescriptorproto::mutable_type_name() {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kemptystring) {
    type_name_ = new ::std::string;
  }
  return type_name_;
}
inline ::std::string* fielddescriptorproto::release_type_name() {
  clear_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = type_name_;
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fielddescriptorproto::set_allocated_type_name(::std::string* type_name) {
  if (type_name_ != &::google::protobuf::internal::kemptystring) {
    delete type_name_;
  }
  if (type_name) {
    set_has_type_name();
    type_name_ = type_name;
  } else {
    clear_has_type_name();
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string extendee = 2;
inline bool fielddescriptorproto::has_extendee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fielddescriptorproto::set_has_extendee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fielddescriptorproto::clear_has_extendee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fielddescriptorproto::clear_extendee() {
  if (extendee_ != &::google::protobuf::internal::kemptystring) {
    extendee_->clear();
  }
  clear_has_extendee();
}
inline const ::std::string& fielddescriptorproto::extendee() const {
  return *extendee_;
}
inline void fielddescriptorproto::set_extendee(const ::std::string& value) {
  set_has_extendee();
  if (extendee_ == &::google::protobuf::internal::kemptystring) {
    extendee_ = new ::std::string;
  }
  extendee_->assign(value);
}
inline void fielddescriptorproto::set_extendee(const char* value) {
  set_has_extendee();
  if (extendee_ == &::google::protobuf::internal::kemptystring) {
    extendee_ = new ::std::string;
  }
  extendee_->assign(value);
}
inline void fielddescriptorproto::set_extendee(const char* value, size_t size) {
  set_has_extendee();
  if (extendee_ == &::google::protobuf::internal::kemptystring) {
    extendee_ = new ::std::string;
  }
  extendee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fielddescriptorproto::mutable_extendee() {
  set_has_extendee();
  if (extendee_ == &::google::protobuf::internal::kemptystring) {
    extendee_ = new ::std::string;
  }
  return extendee_;
}
inline ::std::string* fielddescriptorproto::release_extendee() {
  clear_has_extendee();
  if (extendee_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = extendee_;
    extendee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fielddescriptorproto::set_allocated_extendee(::std::string* extendee) {
  if (extendee_ != &::google::protobuf::internal::kemptystring) {
    delete extendee_;
  }
  if (extendee) {
    set_has_extendee();
    extendee_ = extendee;
  } else {
    clear_has_extendee();
    extendee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string default_value = 7;
inline bool fielddescriptorproto::has_default_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fielddescriptorproto::set_has_default_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fielddescriptorproto::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fielddescriptorproto::clear_default_value() {
  if (default_value_ != &::google::protobuf::internal::kemptystring) {
    default_value_->clear();
  }
  clear_has_default_value();
}
inline const ::std::string& fielddescriptorproto::default_value() const {
  return *default_value_;
}
inline void fielddescriptorproto::set_default_value(const ::std::string& value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kemptystring) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
}
inline void fielddescriptorproto::set_default_value(const char* value) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kemptystring) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(value);
}
inline void fielddescriptorproto::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kemptystring) {
    default_value_ = new ::std::string;
  }
  default_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fielddescriptorproto::mutable_default_value() {
  set_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kemptystring) {
    default_value_ = new ::std::string;
  }
  return default_value_;
}
inline ::std::string* fielddescriptorproto::release_default_value() {
  clear_has_default_value();
  if (default_value_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = default_value_;
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fielddescriptorproto::set_allocated_default_value(::std::string* default_value) {
  if (default_value_ != &::google::protobuf::internal::kemptystring) {
    delete default_value_;
  }
  if (default_value) {
    set_has_default_value();
    default_value_ = default_value;
  } else {
    clear_has_default_value();
    default_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional .google.protobuf.fieldoptions options = 8;
inline bool fielddescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void fielddescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000080u;
}
inline void fielddescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void fielddescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::fieldoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::fieldoptions& fielddescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::fieldoptions* fielddescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::fieldoptions;
  return options_;
}
inline ::google::protobuf::fieldoptions* fielddescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::fieldoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void fielddescriptorproto::set_allocated_options(::google::protobuf::fieldoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// enumdescriptorproto

// optional string name = 1;
inline bool enumdescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enumdescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enumdescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enumdescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& enumdescriptorproto::name() const {
  return *name_;
}
inline void enumdescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void enumdescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void enumdescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* enumdescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* enumdescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void enumdescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// repeated .google.protobuf.enumvaluedescriptorproto value = 2;
inline int enumdescriptorproto::value_size() const {
  return value_.size();
}
inline void enumdescriptorproto::clear_value() {
  value_.clear();
}
inline const ::google::protobuf::enumvaluedescriptorproto& enumdescriptorproto::value(int index) const {
  return value_.get(index);
}
inline ::google::protobuf::enumvaluedescriptorproto* enumdescriptorproto::mutable_value(int index) {
  return value_.mutable(index);
}
inline ::google::protobuf::enumvaluedescriptorproto* enumdescriptorproto::add_value() {
  return value_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::enumvaluedescriptorproto >&
enumdescriptorproto::value() const {
  return value_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::enumvaluedescriptorproto >*
enumdescriptorproto::mutable_value() {
  return &value_;
}

// optional .google.protobuf.enumoptions options = 3;
inline bool enumdescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void enumdescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void enumdescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void enumdescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::enumoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::enumoptions& enumdescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::enumoptions* enumdescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::enumoptions;
  return options_;
}
inline ::google::protobuf::enumoptions* enumdescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::enumoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void enumdescriptorproto::set_allocated_options(::google::protobuf::enumoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// enumvaluedescriptorproto

// optional string name = 1;
inline bool enumvaluedescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enumvaluedescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enumvaluedescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enumvaluedescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& enumvaluedescriptorproto::name() const {
  return *name_;
}
inline void enumvaluedescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void enumvaluedescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void enumvaluedescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* enumvaluedescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* enumvaluedescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void enumvaluedescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional int32 number = 2;
inline bool enumvaluedescriptorproto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void enumvaluedescriptorproto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void enumvaluedescriptorproto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void enumvaluedescriptorproto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 enumvaluedescriptorproto::number() const {
  return number_;
}
inline void enumvaluedescriptorproto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional .google.protobuf.enumvalueoptions options = 3;
inline bool enumvaluedescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void enumvaluedescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void enumvaluedescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void enumvaluedescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::enumvalueoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::enumvalueoptions& enumvaluedescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::enumvalueoptions* enumvaluedescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::enumvalueoptions;
  return options_;
}
inline ::google::protobuf::enumvalueoptions* enumvaluedescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::enumvalueoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void enumvaluedescriptorproto::set_allocated_options(::google::protobuf::enumvalueoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// servicedescriptorproto

// optional string name = 1;
inline bool servicedescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void servicedescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void servicedescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void servicedescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& servicedescriptorproto::name() const {
  return *name_;
}
inline void servicedescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void servicedescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void servicedescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* servicedescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* servicedescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void servicedescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// repeated .google.protobuf.methoddescriptorproto method = 2;
inline int servicedescriptorproto::method_size() const {
  return method_.size();
}
inline void servicedescriptorproto::clear_method() {
  method_.clear();
}
inline const ::google::protobuf::methoddescriptorproto& servicedescriptorproto::method(int index) const {
  return method_.get(index);
}
inline ::google::protobuf::methoddescriptorproto* servicedescriptorproto::mutable_method(int index) {
  return method_.mutable(index);
}
inline ::google::protobuf::methoddescriptorproto* servicedescriptorproto::add_method() {
  return method_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::methoddescriptorproto >&
servicedescriptorproto::method() const {
  return method_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::methoddescriptorproto >*
servicedescriptorproto::mutable_method() {
  return &method_;
}

// optional .google.protobuf.serviceoptions options = 3;
inline bool servicedescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void servicedescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void servicedescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void servicedescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::serviceoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::serviceoptions& servicedescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::serviceoptions* servicedescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::serviceoptions;
  return options_;
}
inline ::google::protobuf::serviceoptions* servicedescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::serviceoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void servicedescriptorproto::set_allocated_options(::google::protobuf::serviceoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// methoddescriptorproto

// optional string name = 1;
inline bool methoddescriptorproto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void methoddescriptorproto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void methoddescriptorproto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void methoddescriptorproto::clear_name() {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& methoddescriptorproto::name() const {
  return *name_;
}
inline void methoddescriptorproto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void methoddescriptorproto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void methoddescriptorproto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* methoddescriptorproto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* methoddescriptorproto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void methoddescriptorproto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kemptystring) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string input_type = 2;
inline bool methoddescriptorproto::has_input_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void methoddescriptorproto::set_has_input_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void methoddescriptorproto::clear_has_input_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void methoddescriptorproto::clear_input_type() {
  if (input_type_ != &::google::protobuf::internal::kemptystring) {
    input_type_->clear();
  }
  clear_has_input_type();
}
inline const ::std::string& methoddescriptorproto::input_type() const {
  return *input_type_;
}
inline void methoddescriptorproto::set_input_type(const ::std::string& value) {
  set_has_input_type();
  if (input_type_ == &::google::protobuf::internal::kemptystring) {
    input_type_ = new ::std::string;
  }
  input_type_->assign(value);
}
inline void methoddescriptorproto::set_input_type(const char* value) {
  set_has_input_type();
  if (input_type_ == &::google::protobuf::internal::kemptystring) {
    input_type_ = new ::std::string;
  }
  input_type_->assign(value);
}
inline void methoddescriptorproto::set_input_type(const char* value, size_t size) {
  set_has_input_type();
  if (input_type_ == &::google::protobuf::internal::kemptystring) {
    input_type_ = new ::std::string;
  }
  input_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* methoddescriptorproto::mutable_input_type() {
  set_has_input_type();
  if (input_type_ == &::google::protobuf::internal::kemptystring) {
    input_type_ = new ::std::string;
  }
  return input_type_;
}
inline ::std::string* methoddescriptorproto::release_input_type() {
  clear_has_input_type();
  if (input_type_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = input_type_;
    input_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void methoddescriptorproto::set_allocated_input_type(::std::string* input_type) {
  if (input_type_ != &::google::protobuf::internal::kemptystring) {
    delete input_type_;
  }
  if (input_type) {
    set_has_input_type();
    input_type_ = input_type;
  } else {
    clear_has_input_type();
    input_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string output_type = 3;
inline bool methoddescriptorproto::has_output_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void methoddescriptorproto::set_has_output_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void methoddescriptorproto::clear_has_output_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void methoddescriptorproto::clear_output_type() {
  if (output_type_ != &::google::protobuf::internal::kemptystring) {
    output_type_->clear();
  }
  clear_has_output_type();
}
inline const ::std::string& methoddescriptorproto::output_type() const {
  return *output_type_;
}
inline void methoddescriptorproto::set_output_type(const ::std::string& value) {
  set_has_output_type();
  if (output_type_ == &::google::protobuf::internal::kemptystring) {
    output_type_ = new ::std::string;
  }
  output_type_->assign(value);
}
inline void methoddescriptorproto::set_output_type(const char* value) {
  set_has_output_type();
  if (output_type_ == &::google::protobuf::internal::kemptystring) {
    output_type_ = new ::std::string;
  }
  output_type_->assign(value);
}
inline void methoddescriptorproto::set_output_type(const char* value, size_t size) {
  set_has_output_type();
  if (output_type_ == &::google::protobuf::internal::kemptystring) {
    output_type_ = new ::std::string;
  }
  output_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* methoddescriptorproto::mutable_output_type() {
  set_has_output_type();
  if (output_type_ == &::google::protobuf::internal::kemptystring) {
    output_type_ = new ::std::string;
  }
  return output_type_;
}
inline ::std::string* methoddescriptorproto::release_output_type() {
  clear_has_output_type();
  if (output_type_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = output_type_;
    output_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void methoddescriptorproto::set_allocated_output_type(::std::string* output_type) {
  if (output_type_ != &::google::protobuf::internal::kemptystring) {
    delete output_type_;
  }
  if (output_type) {
    set_has_output_type();
    output_type_ = output_type;
  } else {
    clear_has_output_type();
    output_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional .google.protobuf.methodoptions options = 4;
inline bool methoddescriptorproto::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void methoddescriptorproto::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void methoddescriptorproto::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void methoddescriptorproto::clear_options() {
  if (options_ != null) options_->::google::protobuf::methodoptions::clear();
  clear_has_options();
}
inline const ::google::protobuf::methodoptions& methoddescriptorproto::options() const {
  return options_ != null ? *options_ : *default_instance_->options_;
}
inline ::google::protobuf::methodoptions* methoddescriptorproto::mutable_options() {
  set_has_options();
  if (options_ == null) options_ = new ::google::protobuf::methodoptions;
  return options_;
}
inline ::google::protobuf::methodoptions* methoddescriptorproto::release_options() {
  clear_has_options();
  ::google::protobuf::methodoptions* temp = options_;
  options_ = null;
  return temp;
}
inline void methoddescriptorproto::set_allocated_options(::google::protobuf::methodoptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// fileoptions

// optional string java_package = 1;
inline bool fileoptions::has_java_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fileoptions::set_has_java_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fileoptions::clear_has_java_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fileoptions::clear_java_package() {
  if (java_package_ != &::google::protobuf::internal::kemptystring) {
    java_package_->clear();
  }
  clear_has_java_package();
}
inline const ::std::string& fileoptions::java_package() const {
  return *java_package_;
}
inline void fileoptions::set_java_package(const ::std::string& value) {
  set_has_java_package();
  if (java_package_ == &::google::protobuf::internal::kemptystring) {
    java_package_ = new ::std::string;
  }
  java_package_->assign(value);
}
inline void fileoptions::set_java_package(const char* value) {
  set_has_java_package();
  if (java_package_ == &::google::protobuf::internal::kemptystring) {
    java_package_ = new ::std::string;
  }
  java_package_->assign(value);
}
inline void fileoptions::set_java_package(const char* value, size_t size) {
  set_has_java_package();
  if (java_package_ == &::google::protobuf::internal::kemptystring) {
    java_package_ = new ::std::string;
  }
  java_package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fileoptions::mutable_java_package() {
  set_has_java_package();
  if (java_package_ == &::google::protobuf::internal::kemptystring) {
    java_package_ = new ::std::string;
  }
  return java_package_;
}
inline ::std::string* fileoptions::release_java_package() {
  clear_has_java_package();
  if (java_package_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = java_package_;
    java_package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fileoptions::set_allocated_java_package(::std::string* java_package) {
  if (java_package_ != &::google::protobuf::internal::kemptystring) {
    delete java_package_;
  }
  if (java_package) {
    set_has_java_package();
    java_package_ = java_package;
  } else {
    clear_has_java_package();
    java_package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string java_outer_classname = 8;
inline bool fileoptions::has_java_outer_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fileoptions::set_has_java_outer_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fileoptions::clear_has_java_outer_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fileoptions::clear_java_outer_classname() {
  if (java_outer_classname_ != &::google::protobuf::internal::kemptystring) {
    java_outer_classname_->clear();
  }
  clear_has_java_outer_classname();
}
inline const ::std::string& fileoptions::java_outer_classname() const {
  return *java_outer_classname_;
}
inline void fileoptions::set_java_outer_classname(const ::std::string& value) {
  set_has_java_outer_classname();
  if (java_outer_classname_ == &::google::protobuf::internal::kemptystring) {
    java_outer_classname_ = new ::std::string;
  }
  java_outer_classname_->assign(value);
}
inline void fileoptions::set_java_outer_classname(const char* value) {
  set_has_java_outer_classname();
  if (java_outer_classname_ == &::google::protobuf::internal::kemptystring) {
    java_outer_classname_ = new ::std::string;
  }
  java_outer_classname_->assign(value);
}
inline void fileoptions::set_java_outer_classname(const char* value, size_t size) {
  set_has_java_outer_classname();
  if (java_outer_classname_ == &::google::protobuf::internal::kemptystring) {
    java_outer_classname_ = new ::std::string;
  }
  java_outer_classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fileoptions::mutable_java_outer_classname() {
  set_has_java_outer_classname();
  if (java_outer_classname_ == &::google::protobuf::internal::kemptystring) {
    java_outer_classname_ = new ::std::string;
  }
  return java_outer_classname_;
}
inline ::std::string* fileoptions::release_java_outer_classname() {
  clear_has_java_outer_classname();
  if (java_outer_classname_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = java_outer_classname_;
    java_outer_classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fileoptions::set_allocated_java_outer_classname(::std::string* java_outer_classname) {
  if (java_outer_classname_ != &::google::protobuf::internal::kemptystring) {
    delete java_outer_classname_;
  }
  if (java_outer_classname) {
    set_has_java_outer_classname();
    java_outer_classname_ = java_outer_classname;
  } else {
    clear_has_java_outer_classname();
    java_outer_classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional bool java_multiple_files = 10 [default = false];
inline bool fileoptions::has_java_multiple_files() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fileoptions::set_has_java_multiple_files() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fileoptions::clear_has_java_multiple_files() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fileoptions::clear_java_multiple_files() {
  java_multiple_files_ = false;
  clear_has_java_multiple_files();
}
inline bool fileoptions::java_multiple_files() const {
  return java_multiple_files_;
}
inline void fileoptions::set_java_multiple_files(bool value) {
  set_has_java_multiple_files();
  java_multiple_files_ = value;
}

// optional bool java_generate_equals_and_hash = 20 [default = false];
inline bool fileoptions::has_java_generate_equals_and_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fileoptions::set_has_java_generate_equals_and_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fileoptions::clear_has_java_generate_equals_and_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fileoptions::clear_java_generate_equals_and_hash() {
  java_generate_equals_and_hash_ = false;
  clear_has_java_generate_equals_and_hash();
}
inline bool fileoptions::java_generate_equals_and_hash() const {
  return java_generate_equals_and_hash_;
}
inline void fileoptions::set_java_generate_equals_and_hash(bool value) {
  set_has_java_generate_equals_and_hash();
  java_generate_equals_and_hash_ = value;
}

// optional .google.protobuf.fileoptions.optimizemode optimize_for = 9 [default = speed];
inline bool fileoptions::has_optimize_for() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fileoptions::set_has_optimize_for() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fileoptions::clear_has_optimize_for() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fileoptions::clear_optimize_for() {
  optimize_for_ = 1;
  clear_has_optimize_for();
}
inline ::google::protobuf::fileoptions_optimizemode fileoptions::optimize_for() const {
  return static_cast< ::google::protobuf::fileoptions_optimizemode >(optimize_for_);
}
inline void fileoptions::set_optimize_for(::google::protobuf::fileoptions_optimizemode value) {
  assert(::google::protobuf::fileoptions_optimizemode_isvalid(value));
  set_has_optimize_for();
  optimize_for_ = value;
}

// optional string go_package = 11;
inline bool fileoptions::has_go_package() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fileoptions::set_has_go_package() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fileoptions::clear_has_go_package() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fileoptions::clear_go_package() {
  if (go_package_ != &::google::protobuf::internal::kemptystring) {
    go_package_->clear();
  }
  clear_has_go_package();
}
inline const ::std::string& fileoptions::go_package() const {
  return *go_package_;
}
inline void fileoptions::set_go_package(const ::std::string& value) {
  set_has_go_package();
  if (go_package_ == &::google::protobuf::internal::kemptystring) {
    go_package_ = new ::std::string;
  }
  go_package_->assign(value);
}
inline void fileoptions::set_go_package(const char* value) {
  set_has_go_package();
  if (go_package_ == &::google::protobuf::internal::kemptystring) {
    go_package_ = new ::std::string;
  }
  go_package_->assign(value);
}
inline void fileoptions::set_go_package(const char* value, size_t size) {
  set_has_go_package();
  if (go_package_ == &::google::protobuf::internal::kemptystring) {
    go_package_ = new ::std::string;
  }
  go_package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fileoptions::mutable_go_package() {
  set_has_go_package();
  if (go_package_ == &::google::protobuf::internal::kemptystring) {
    go_package_ = new ::std::string;
  }
  return go_package_;
}
inline ::std::string* fileoptions::release_go_package() {
  clear_has_go_package();
  if (go_package_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = go_package_;
    go_package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fileoptions::set_allocated_go_package(::std::string* go_package) {
  if (go_package_ != &::google::protobuf::internal::kemptystring) {
    delete go_package_;
  }
  if (go_package) {
    set_has_go_package();
    go_package_ = go_package;
  } else {
    clear_has_go_package();
    go_package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional bool cc_generic_services = 16 [default = false];
inline bool fileoptions::has_cc_generic_services() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fileoptions::set_has_cc_generic_services() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fileoptions::clear_has_cc_generic_services() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fileoptions::clear_cc_generic_services() {
  cc_generic_services_ = false;
  clear_has_cc_generic_services();
}
inline bool fileoptions::cc_generic_services() const {
  return cc_generic_services_;
}
inline void fileoptions::set_cc_generic_services(bool value) {
  set_has_cc_generic_services();
  cc_generic_services_ = value;
}

// optional bool java_generic_services = 17 [default = false];
inline bool fileoptions::has_java_generic_services() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void fileoptions::set_has_java_generic_services() {
  _has_bits_[0] |= 0x00000080u;
}
inline void fileoptions::clear_has_java_generic_services() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void fileoptions::clear_java_generic_services() {
  java_generic_services_ = false;
  clear_has_java_generic_services();
}
inline bool fileoptions::java_generic_services() const {
  return java_generic_services_;
}
inline void fileoptions::set_java_generic_services(bool value) {
  set_has_java_generic_services();
  java_generic_services_ = value;
}

// optional bool py_generic_services = 18 [default = false];
inline bool fileoptions::has_py_generic_services() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void fileoptions::set_has_py_generic_services() {
  _has_bits_[0] |= 0x00000100u;
}
inline void fileoptions::clear_has_py_generic_services() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void fileoptions::clear_py_generic_services() {
  py_generic_services_ = false;
  clear_has_py_generic_services();
}
inline bool fileoptions::py_generic_services() const {
  return py_generic_services_;
}
inline void fileoptions::set_py_generic_services(bool value) {
  set_has_py_generic_services();
  py_generic_services_ = value;
}

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int fileoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void fileoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& fileoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* fileoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* fileoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
fileoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
fileoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// messageoptions

// optional bool message_set_wire_format = 1 [default = false];
inline bool messageoptions::has_message_set_wire_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void messageoptions::set_has_message_set_wire_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void messageoptions::clear_has_message_set_wire_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void messageoptions::clear_message_set_wire_format() {
  message_set_wire_format_ = false;
  clear_has_message_set_wire_format();
}
inline bool messageoptions::message_set_wire_format() const {
  return message_set_wire_format_;
}
inline void messageoptions::set_message_set_wire_format(bool value) {
  set_has_message_set_wire_format();
  message_set_wire_format_ = value;
}

// optional bool no_standard_descriptor_accessor = 2 [default = false];
inline bool messageoptions::has_no_standard_descriptor_accessor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void messageoptions::set_has_no_standard_descriptor_accessor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void messageoptions::clear_has_no_standard_descriptor_accessor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void messageoptions::clear_no_standard_descriptor_accessor() {
  no_standard_descriptor_accessor_ = false;
  clear_has_no_standard_descriptor_accessor();
}
inline bool messageoptions::no_standard_descriptor_accessor() const {
  return no_standard_descriptor_accessor_;
}
inline void messageoptions::set_no_standard_descriptor_accessor(bool value) {
  set_has_no_standard_descriptor_accessor();
  no_standard_descriptor_accessor_ = value;
}

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int messageoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void messageoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& messageoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* messageoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* messageoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
messageoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
messageoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// fieldoptions

// optional .google.protobuf.fieldoptions.ctype ctype = 1 [default = string];
inline bool fieldoptions::has_ctype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fieldoptions::set_has_ctype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fieldoptions::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fieldoptions::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::google::protobuf::fieldoptions_ctype fieldoptions::ctype() const {
  return static_cast< ::google::protobuf::fieldoptions_ctype >(ctype_);
}
inline void fieldoptions::set_ctype(::google::protobuf::fieldoptions_ctype value) {
  assert(::google::protobuf::fieldoptions_ctype_isvalid(value));
  set_has_ctype();
  ctype_ = value;
}

// optional bool packed = 2;
inline bool fieldoptions::has_packed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fieldoptions::set_has_packed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fieldoptions::clear_has_packed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fieldoptions::clear_packed() {
  packed_ = false;
  clear_has_packed();
}
inline bool fieldoptions::packed() const {
  return packed_;
}
inline void fieldoptions::set_packed(bool value) {
  set_has_packed();
  packed_ = value;
}

// optional bool lazy = 5 [default = false];
inline bool fieldoptions::has_lazy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fieldoptions::set_has_lazy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fieldoptions::clear_has_lazy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fieldoptions::clear_lazy() {
  lazy_ = false;
  clear_has_lazy();
}
inline bool fieldoptions::lazy() const {
  return lazy_;
}
inline void fieldoptions::set_lazy(bool value) {
  set_has_lazy();
  lazy_ = value;
}

// optional bool deprecated = 3 [default = false];
inline bool fieldoptions::has_deprecated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fieldoptions::set_has_deprecated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fieldoptions::clear_has_deprecated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fieldoptions::clear_deprecated() {
  deprecated_ = false;
  clear_has_deprecated();
}
inline bool fieldoptions::deprecated() const {
  return deprecated_;
}
inline void fieldoptions::set_deprecated(bool value) {
  set_has_deprecated();
  deprecated_ = value;
}

// optional string experimental_map_key = 9;
inline bool fieldoptions::has_experimental_map_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fieldoptions::set_has_experimental_map_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fieldoptions::clear_has_experimental_map_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fieldoptions::clear_experimental_map_key() {
  if (experimental_map_key_ != &::google::protobuf::internal::kemptystring) {
    experimental_map_key_->clear();
  }
  clear_has_experimental_map_key();
}
inline const ::std::string& fieldoptions::experimental_map_key() const {
  return *experimental_map_key_;
}
inline void fieldoptions::set_experimental_map_key(const ::std::string& value) {
  set_has_experimental_map_key();
  if (experimental_map_key_ == &::google::protobuf::internal::kemptystring) {
    experimental_map_key_ = new ::std::string;
  }
  experimental_map_key_->assign(value);
}
inline void fieldoptions::set_experimental_map_key(const char* value) {
  set_has_experimental_map_key();
  if (experimental_map_key_ == &::google::protobuf::internal::kemptystring) {
    experimental_map_key_ = new ::std::string;
  }
  experimental_map_key_->assign(value);
}
inline void fieldoptions::set_experimental_map_key(const char* value, size_t size) {
  set_has_experimental_map_key();
  if (experimental_map_key_ == &::google::protobuf::internal::kemptystring) {
    experimental_map_key_ = new ::std::string;
  }
  experimental_map_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fieldoptions::mutable_experimental_map_key() {
  set_has_experimental_map_key();
  if (experimental_map_key_ == &::google::protobuf::internal::kemptystring) {
    experimental_map_key_ = new ::std::string;
  }
  return experimental_map_key_;
}
inline ::std::string* fieldoptions::release_experimental_map_key() {
  clear_has_experimental_map_key();
  if (experimental_map_key_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = experimental_map_key_;
    experimental_map_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void fieldoptions::set_allocated_experimental_map_key(::std::string* experimental_map_key) {
  if (experimental_map_key_ != &::google::protobuf::internal::kemptystring) {
    delete experimental_map_key_;
  }
  if (experimental_map_key) {
    set_has_experimental_map_key();
    experimental_map_key_ = experimental_map_key;
  } else {
    clear_has_experimental_map_key();
    experimental_map_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional bool weak = 10 [default = false];
inline bool fieldoptions::has_weak() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fieldoptions::set_has_weak() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fieldoptions::clear_has_weak() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fieldoptions::clear_weak() {
  weak_ = false;
  clear_has_weak();
}
inline bool fieldoptions::weak() const {
  return weak_;
}
inline void fieldoptions::set_weak(bool value) {
  set_has_weak();
  weak_ = value;
}

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int fieldoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void fieldoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& fieldoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* fieldoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* fieldoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
fieldoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
fieldoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// enumoptions

// optional bool allow_alias = 2 [default = true];
inline bool enumoptions::has_allow_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void enumoptions::set_has_allow_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void enumoptions::clear_has_allow_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void enumoptions::clear_allow_alias() {
  allow_alias_ = true;
  clear_has_allow_alias();
}
inline bool enumoptions::allow_alias() const {
  return allow_alias_;
}
inline void enumoptions::set_allow_alias(bool value) {
  set_has_allow_alias();
  allow_alias_ = value;
}

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int enumoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void enumoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& enumoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* enumoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* enumoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
enumoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
enumoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// enumvalueoptions

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int enumvalueoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void enumvalueoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& enumvalueoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* enumvalueoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* enumvalueoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
enumvalueoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
enumvalueoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// serviceoptions

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int serviceoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void serviceoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& serviceoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* serviceoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* serviceoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
serviceoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
serviceoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// methodoptions

// repeated .google.protobuf.uninterpretedoption uninterpreted_option = 999;
inline int methodoptions::uninterpreted_option_size() const {
  return uninterpreted_option_.size();
}
inline void methodoptions::clear_uninterpreted_option() {
  uninterpreted_option_.clear();
}
inline const ::google::protobuf::uninterpretedoption& methodoptions::uninterpreted_option(int index) const {
  return uninterpreted_option_.get(index);
}
inline ::google::protobuf::uninterpretedoption* methodoptions::mutable_uninterpreted_option(int index) {
  return uninterpreted_option_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption* methodoptions::add_uninterpreted_option() {
  return uninterpreted_option_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >&
methodoptions::uninterpreted_option() const {
  return uninterpreted_option_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption >*
methodoptions::mutable_uninterpreted_option() {
  return &uninterpreted_option_;
}

// -------------------------------------------------------------------

// uninterpretedoption_namepart

// required string name_part = 1;
inline bool uninterpretedoption_namepart::has_name_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void uninterpretedoption_namepart::set_has_name_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void uninterpretedoption_namepart::clear_has_name_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void uninterpretedoption_namepart::clear_name_part() {
  if (name_part_ != &::google::protobuf::internal::kemptystring) {
    name_part_->clear();
  }
  clear_has_name_part();
}
inline const ::std::string& uninterpretedoption_namepart::name_part() const {
  return *name_part_;
}
inline void uninterpretedoption_namepart::set_name_part(const ::std::string& value) {
  set_has_name_part();
  if (name_part_ == &::google::protobuf::internal::kemptystring) {
    name_part_ = new ::std::string;
  }
  name_part_->assign(value);
}
inline void uninterpretedoption_namepart::set_name_part(const char* value) {
  set_has_name_part();
  if (name_part_ == &::google::protobuf::internal::kemptystring) {
    name_part_ = new ::std::string;
  }
  name_part_->assign(value);
}
inline void uninterpretedoption_namepart::set_name_part(const char* value, size_t size) {
  set_has_name_part();
  if (name_part_ == &::google::protobuf::internal::kemptystring) {
    name_part_ = new ::std::string;
  }
  name_part_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* uninterpretedoption_namepart::mutable_name_part() {
  set_has_name_part();
  if (name_part_ == &::google::protobuf::internal::kemptystring) {
    name_part_ = new ::std::string;
  }
  return name_part_;
}
inline ::std::string* uninterpretedoption_namepart::release_name_part() {
  clear_has_name_part();
  if (name_part_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = name_part_;
    name_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void uninterpretedoption_namepart::set_allocated_name_part(::std::string* name_part) {
  if (name_part_ != &::google::protobuf::internal::kemptystring) {
    delete name_part_;
  }
  if (name_part) {
    set_has_name_part();
    name_part_ = name_part;
  } else {
    clear_has_name_part();
    name_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// required bool is_extension = 2;
inline bool uninterpretedoption_namepart::has_is_extension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void uninterpretedoption_namepart::set_has_is_extension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void uninterpretedoption_namepart::clear_has_is_extension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void uninterpretedoption_namepart::clear_is_extension() {
  is_extension_ = false;
  clear_has_is_extension();
}
inline bool uninterpretedoption_namepart::is_extension() const {
  return is_extension_;
}
inline void uninterpretedoption_namepart::set_is_extension(bool value) {
  set_has_is_extension();
  is_extension_ = value;
}

// -------------------------------------------------------------------

// uninterpretedoption

// repeated .google.protobuf.uninterpretedoption.namepart name = 2;
inline int uninterpretedoption::name_size() const {
  return name_.size();
}
inline void uninterpretedoption::clear_name() {
  name_.clear();
}
inline const ::google::protobuf::uninterpretedoption_namepart& uninterpretedoption::name(int index) const {
  return name_.get(index);
}
inline ::google::protobuf::uninterpretedoption_namepart* uninterpretedoption::mutable_name(int index) {
  return name_.mutable(index);
}
inline ::google::protobuf::uninterpretedoption_namepart* uninterpretedoption::add_name() {
  return name_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption_namepart >&
uninterpretedoption::name() const {
  return name_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::uninterpretedoption_namepart >*
uninterpretedoption::mutable_name() {
  return &name_;
}

// optional string identifier_value = 3;
inline bool uninterpretedoption::has_identifier_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void uninterpretedoption::set_has_identifier_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void uninterpretedoption::clear_has_identifier_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void uninterpretedoption::clear_identifier_value() {
  if (identifier_value_ != &::google::protobuf::internal::kemptystring) {
    identifier_value_->clear();
  }
  clear_has_identifier_value();
}
inline const ::std::string& uninterpretedoption::identifier_value() const {
  return *identifier_value_;
}
inline void uninterpretedoption::set_identifier_value(const ::std::string& value) {
  set_has_identifier_value();
  if (identifier_value_ == &::google::protobuf::internal::kemptystring) {
    identifier_value_ = new ::std::string;
  }
  identifier_value_->assign(value);
}
inline void uninterpretedoption::set_identifier_value(const char* value) {
  set_has_identifier_value();
  if (identifier_value_ == &::google::protobuf::internal::kemptystring) {
    identifier_value_ = new ::std::string;
  }
  identifier_value_->assign(value);
}
inline void uninterpretedoption::set_identifier_value(const char* value, size_t size) {
  set_has_identifier_value();
  if (identifier_value_ == &::google::protobuf::internal::kemptystring) {
    identifier_value_ = new ::std::string;
  }
  identifier_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* uninterpretedoption::mutable_identifier_value() {
  set_has_identifier_value();
  if (identifier_value_ == &::google::protobuf::internal::kemptystring) {
    identifier_value_ = new ::std::string;
  }
  return identifier_value_;
}
inline ::std::string* uninterpretedoption::release_identifier_value() {
  clear_has_identifier_value();
  if (identifier_value_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = identifier_value_;
    identifier_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void uninterpretedoption::set_allocated_identifier_value(::std::string* identifier_value) {
  if (identifier_value_ != &::google::protobuf::internal::kemptystring) {
    delete identifier_value_;
  }
  if (identifier_value) {
    set_has_identifier_value();
    identifier_value_ = identifier_value;
  } else {
    clear_has_identifier_value();
    identifier_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional uint64 positive_int_value = 4;
inline bool uninterpretedoption::has_positive_int_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void uninterpretedoption::set_has_positive_int_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void uninterpretedoption::clear_has_positive_int_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void uninterpretedoption::clear_positive_int_value() {
  positive_int_value_ = google_ulonglong(0);
  clear_has_positive_int_value();
}
inline ::google::protobuf::uint64 uninterpretedoption::positive_int_value() const {
  return positive_int_value_;
}
inline void uninterpretedoption::set_positive_int_value(::google::protobuf::uint64 value) {
  set_has_positive_int_value();
  positive_int_value_ = value;
}

// optional int64 negative_int_value = 5;
inline bool uninterpretedoption::has_negative_int_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void uninterpretedoption::set_has_negative_int_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void uninterpretedoption::clear_has_negative_int_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void uninterpretedoption::clear_negative_int_value() {
  negative_int_value_ = google_longlong(0);
  clear_has_negative_int_value();
}
inline ::google::protobuf::int64 uninterpretedoption::negative_int_value() const {
  return negative_int_value_;
}
inline void uninterpretedoption::set_negative_int_value(::google::protobuf::int64 value) {
  set_has_negative_int_value();
  negative_int_value_ = value;
}

// optional double double_value = 6;
inline bool uninterpretedoption::has_double_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void uninterpretedoption::set_has_double_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void uninterpretedoption::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void uninterpretedoption::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double uninterpretedoption::double_value() const {
  return double_value_;
}
inline void uninterpretedoption::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional bytes string_value = 7;
inline bool uninterpretedoption::has_string_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void uninterpretedoption::set_has_string_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void uninterpretedoption::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void uninterpretedoption::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kemptystring) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& uninterpretedoption::string_value() const {
  return *string_value_;
}
inline void uninterpretedoption::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kemptystring) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void uninterpretedoption::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kemptystring) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void uninterpretedoption::set_string_value(const void* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kemptystring) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* uninterpretedoption::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kemptystring) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* uninterpretedoption::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void uninterpretedoption::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::kemptystring) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string aggregate_value = 8;
inline bool uninterpretedoption::has_aggregate_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void uninterpretedoption::set_has_aggregate_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void uninterpretedoption::clear_has_aggregate_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void uninterpretedoption::clear_aggregate_value() {
  if (aggregate_value_ != &::google::protobuf::internal::kemptystring) {
    aggregate_value_->clear();
  }
  clear_has_aggregate_value();
}
inline const ::std::string& uninterpretedoption::aggregate_value() const {
  return *aggregate_value_;
}
inline void uninterpretedoption::set_aggregate_value(const ::std::string& value) {
  set_has_aggregate_value();
  if (aggregate_value_ == &::google::protobuf::internal::kemptystring) {
    aggregate_value_ = new ::std::string;
  }
  aggregate_value_->assign(value);
}
inline void uninterpretedoption::set_aggregate_value(const char* value) {
  set_has_aggregate_value();
  if (aggregate_value_ == &::google::protobuf::internal::kemptystring) {
    aggregate_value_ = new ::std::string;
  }
  aggregate_value_->assign(value);
}
inline void uninterpretedoption::set_aggregate_value(const char* value, size_t size) {
  set_has_aggregate_value();
  if (aggregate_value_ == &::google::protobuf::internal::kemptystring) {
    aggregate_value_ = new ::std::string;
  }
  aggregate_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* uninterpretedoption::mutable_aggregate_value() {
  set_has_aggregate_value();
  if (aggregate_value_ == &::google::protobuf::internal::kemptystring) {
    aggregate_value_ = new ::std::string;
  }
  return aggregate_value_;
}
inline ::std::string* uninterpretedoption::release_aggregate_value() {
  clear_has_aggregate_value();
  if (aggregate_value_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = aggregate_value_;
    aggregate_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void uninterpretedoption::set_allocated_aggregate_value(::std::string* aggregate_value) {
  if (aggregate_value_ != &::google::protobuf::internal::kemptystring) {
    delete aggregate_value_;
  }
  if (aggregate_value) {
    set_has_aggregate_value();
    aggregate_value_ = aggregate_value;
  } else {
    clear_has_aggregate_value();
    aggregate_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// -------------------------------------------------------------------

// sourcecodeinfo_location

// repeated int32 path = 1 [packed = true];
inline int sourcecodeinfo_location::path_size() const {
  return path_.size();
}
inline void sourcecodeinfo_location::clear_path() {
  path_.clear();
}
inline ::google::protobuf::int32 sourcecodeinfo_location::path(int index) const {
  return path_.get(index);
}
inline void sourcecodeinfo_location::set_path(int index, ::google::protobuf::int32 value) {
  path_.set(index, value);
}
inline void sourcecodeinfo_location::add_path(::google::protobuf::int32 value) {
  path_.add(value);
}
inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
sourcecodeinfo_location::path() const {
  return path_;
}
inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
sourcecodeinfo_location::mutable_path() {
  return &path_;
}

// repeated int32 span = 2 [packed = true];
inline int sourcecodeinfo_location::span_size() const {
  return span_.size();
}
inline void sourcecodeinfo_location::clear_span() {
  span_.clear();
}
inline ::google::protobuf::int32 sourcecodeinfo_location::span(int index) const {
  return span_.get(index);
}
inline void sourcecodeinfo_location::set_span(int index, ::google::protobuf::int32 value) {
  span_.set(index, value);
}
inline void sourcecodeinfo_location::add_span(::google::protobuf::int32 value) {
  span_.add(value);
}
inline const ::google::protobuf::repeatedfield< ::google::protobuf::int32 >&
sourcecodeinfo_location::span() const {
  return span_;
}
inline ::google::protobuf::repeatedfield< ::google::protobuf::int32 >*
sourcecodeinfo_location::mutable_span() {
  return &span_;
}

// optional string leading_comments = 3;
inline bool sourcecodeinfo_location::has_leading_comments() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sourcecodeinfo_location::set_has_leading_comments() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sourcecodeinfo_location::clear_has_leading_comments() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sourcecodeinfo_location::clear_leading_comments() {
  if (leading_comments_ != &::google::protobuf::internal::kemptystring) {
    leading_comments_->clear();
  }
  clear_has_leading_comments();
}
inline const ::std::string& sourcecodeinfo_location::leading_comments() const {
  return *leading_comments_;
}
inline void sourcecodeinfo_location::set_leading_comments(const ::std::string& value) {
  set_has_leading_comments();
  if (leading_comments_ == &::google::protobuf::internal::kemptystring) {
    leading_comments_ = new ::std::string;
  }
  leading_comments_->assign(value);
}
inline void sourcecodeinfo_location::set_leading_comments(const char* value) {
  set_has_leading_comments();
  if (leading_comments_ == &::google::protobuf::internal::kemptystring) {
    leading_comments_ = new ::std::string;
  }
  leading_comments_->assign(value);
}
inline void sourcecodeinfo_location::set_leading_comments(const char* value, size_t size) {
  set_has_leading_comments();
  if (leading_comments_ == &::google::protobuf::internal::kemptystring) {
    leading_comments_ = new ::std::string;
  }
  leading_comments_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sourcecodeinfo_location::mutable_leading_comments() {
  set_has_leading_comments();
  if (leading_comments_ == &::google::protobuf::internal::kemptystring) {
    leading_comments_ = new ::std::string;
  }
  return leading_comments_;
}
inline ::std::string* sourcecodeinfo_location::release_leading_comments() {
  clear_has_leading_comments();
  if (leading_comments_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = leading_comments_;
    leading_comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void sourcecodeinfo_location::set_allocated_leading_comments(::std::string* leading_comments) {
  if (leading_comments_ != &::google::protobuf::internal::kemptystring) {
    delete leading_comments_;
  }
  if (leading_comments) {
    set_has_leading_comments();
    leading_comments_ = leading_comments;
  } else {
    clear_has_leading_comments();
    leading_comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// optional string trailing_comments = 4;
inline bool sourcecodeinfo_location::has_trailing_comments() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sourcecodeinfo_location::set_has_trailing_comments() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sourcecodeinfo_location::clear_has_trailing_comments() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sourcecodeinfo_location::clear_trailing_comments() {
  if (trailing_comments_ != &::google::protobuf::internal::kemptystring) {
    trailing_comments_->clear();
  }
  clear_has_trailing_comments();
}
inline const ::std::string& sourcecodeinfo_location::trailing_comments() const {
  return *trailing_comments_;
}
inline void sourcecodeinfo_location::set_trailing_comments(const ::std::string& value) {
  set_has_trailing_comments();
  if (trailing_comments_ == &::google::protobuf::internal::kemptystring) {
    trailing_comments_ = new ::std::string;
  }
  trailing_comments_->assign(value);
}
inline void sourcecodeinfo_location::set_trailing_comments(const char* value) {
  set_has_trailing_comments();
  if (trailing_comments_ == &::google::protobuf::internal::kemptystring) {
    trailing_comments_ = new ::std::string;
  }
  trailing_comments_->assign(value);
}
inline void sourcecodeinfo_location::set_trailing_comments(const char* value, size_t size) {
  set_has_trailing_comments();
  if (trailing_comments_ == &::google::protobuf::internal::kemptystring) {
    trailing_comments_ = new ::std::string;
  }
  trailing_comments_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sourcecodeinfo_location::mutable_trailing_comments() {
  set_has_trailing_comments();
  if (trailing_comments_ == &::google::protobuf::internal::kemptystring) {
    trailing_comments_ = new ::std::string;
  }
  return trailing_comments_;
}
inline ::std::string* sourcecodeinfo_location::release_trailing_comments() {
  clear_has_trailing_comments();
  if (trailing_comments_ == &::google::protobuf::internal::kemptystring) {
    return null;
  } else {
    ::std::string* temp = trailing_comments_;
    trailing_comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
    return temp;
  }
}
inline void sourcecodeinfo_location::set_allocated_trailing_comments(::std::string* trailing_comments) {
  if (trailing_comments_ != &::google::protobuf::internal::kemptystring) {
    delete trailing_comments_;
  }
  if (trailing_comments) {
    set_has_trailing_comments();
    trailing_comments_ = trailing_comments;
  } else {
    clear_has_trailing_comments();
    trailing_comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kemptystring);
  }
}

// -------------------------------------------------------------------

// sourcecodeinfo

// repeated .google.protobuf.sourcecodeinfo.location location = 1;
inline int sourcecodeinfo::location_size() const {
  return location_.size();
}
inline void sourcecodeinfo::clear_location() {
  location_.clear();
}
inline const ::google::protobuf::sourcecodeinfo_location& sourcecodeinfo::location(int index) const {
  return location_.get(index);
}
inline ::google::protobuf::sourcecodeinfo_location* sourcecodeinfo::mutable_location(int index) {
  return location_.mutable(index);
}
inline ::google::protobuf::sourcecodeinfo_location* sourcecodeinfo::add_location() {
  return location_.add();
}
inline const ::google::protobuf::repeatedptrfield< ::google::protobuf::sourcecodeinfo_location >&
sourcecodeinfo::location() const {
  return location_;
}
inline ::google::protobuf::repeatedptrfield< ::google::protobuf::sourcecodeinfo_location >*
sourcecodeinfo::mutable_location() {
  return &location_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace google

#ifndef swig
namespace google {
namespace protobuf {

template <>
inline const enumdescriptor* getenumdescriptor< ::google::protobuf::fielddescriptorproto_type>() {
  return ::google::protobuf::fielddescriptorproto_type_descriptor();
}
template <>
inline const enumdescriptor* getenumdescriptor< ::google::protobuf::fielddescriptorproto_label>() {
  return ::google::protobuf::fielddescriptorproto_label_descriptor();
}
template <>
inline const enumdescriptor* getenumdescriptor< ::google::protobuf::fileoptions_optimizemode>() {
  return ::google::protobuf::fileoptions_optimizemode_descriptor();
}
template <>
inline const enumdescriptor* getenumdescriptor< ::google::protobuf::fieldoptions_ctype>() {
  return ::google::protobuf::fieldoptions_ctype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // swig

// @@protoc_insertion_point(global_scope)

#endif  // protobuf_google_2fprotobuf_2fdescriptor_2eproto__included
